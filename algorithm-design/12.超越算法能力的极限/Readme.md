# 回溯法
其实就是有剪枝条件的DFS,可以用递归实现
## 相关例子
* 状态空间树（参见书上图12.2）
* 提前剪枝再回溯，重点是提前，避免了过大的解空间
* n 皇后问题
* 哈密顿回路的生成
* 子集和问题的求解
每个元素在不在集合中可以产生一次分叉，然后可以根据目前总和是否大于题目要的和或者剩下元素加起来是否小于题目要的和进行剪枝
## 一般性说明
* 通用模板dfs的递归实现
```cpp
Void BackTrace(int* s,int i) 
{
   if s从1到i是一个解 
      记录s
   else for s_i+1每一个可行解x
         s[I+1]=x;
         BackTrace(S, I+1);
}
```
注意以上实现没有考虑一条路径上节点前后互相的影响，这时候还需要加一个状态的复位
* 减枝技巧：棋盘对称减半(N皇后,这个对称可以按行列或者两个对角线)，预排序(子集和)，设置合理初始值(哈密顿回路)等
## 状态空间树规模的统计
c_0+c_0*c_1+...+c_0*c_1*c_n
c_0为1一般，c_i是随机选择的状态x_i-1对应的可能选择数。整体而言，回溯更适合优化问题，因为这种问题更容易剪枝
## n皇后问题的线性算法
属于根据图形找规律了，缺乏通用性,可以找答案看看这里不总结
## 回溯法的其他几个例子
* 对一个图求三色问题，要求邻接点不同色，则我们可以按一定顺序，每一层是某个点的几个可选的颜色状态，进行回溯法的遍历
* 回溯法生成排列
```cpp
A[100];
Vis[100];
void BackTrace(int* A, int i ,into* Vis) 
{
   if (i == n-1) {
      for (int k = 0; k < n; k++) {
          cout << A[k];    
      } 
      cout << endl;
      return;
   }
   for (int k = 0; k < n; k++) {
      if (Vis[k+1] == 0) {
          A[i] = k+1;
          Vis[k+1] = 1;
          BackTrace(A, i+1,Vis);
          A[i] = 0; //这个算回溯这个名字的由来了
          Vis[k+1] = 0;
      } 
}
```
# 分支界限法
分支界限法相比回溯法关注的主要是优化问题,因此在实现上，分支界限法会根据一些最优的标准来选择优先遍历的分支，不是像dfs总是找最近的遍历,更具体的说它是类bfs的，每一层都要先加入队列，然后根据边界选择分支;相比回溯法，分支界限法需要两个额外的条件：1.对于一课状态空间树的每一个节点所代表的部分解，我们要提供一种方法，计算出这个部分解繁衍出的任何解在目标函数上的最佳值边界（目前状态下理论最优值）2.目前求得的最佳解的值。简而言之，是利用边界函数更新下（上）界，根据下（上）界选择最优解，找到可行解后，对劣于最佳解的分支进行剪枝。
## 分配问题
首先是选出全局的下界，就是每个成员的最小完成成本之和，虽然不一定是可行的；然后再对每一个人可能的任务安排进行选择，然后针对每一个选择更新下界；然后选择下界最优的进行进一步的安排；以此循环之后，生成第一个完整序列后，得到目前最优成本，目前所有叶子节点的下界进行筛选，理论最优成本大于现有最优值的停止遍历，其他的继续遍历直到得到最优的结果。
## 背包问题
对于物品i,按照物品状态价值上届ub = V+(W-w)*(v_i+1/w_i+1)来进行遍历路径的优先选择,V是目前所有物品的价值，w是重量，W是总承重量，i+1要选择v_i+1/w_i+1最大的；对于每一件物品，有包含与不包含两种状态，每个物品的每种状态都进行ub的更新；剪枝的条件是：1.物品超过承重 2.ub小于目前最优ub
### 背包问题的边界函数的优化
我们可以把ub改成按v/w排序的物品，依次放入背包，直到一个物品放不下，把该物品的部分放入以刚好达到承重，此时书包内的物品的价值就是边界值
## 旅行商问题
首先旅行商问题是完全图，所以对于从b到c的路径，反过来就是从c到b的路径，所以我们在遍历时可以只考虑先b后c的路径；在遍历时出队的优先级由边界函数确定，边界函数的计算方法这里选择用所有城市相连的两条最短边长度累加起来再除以2，如果部分路径已经确定则对每个城市使用确定边和最小边的距离之和再除以2，这个函数显然就是目前能够得到的路径最短距离了（虽然不一定是可行的）。根据此函数给定的优先级进行遍历，在达到叶子节点后，对目前的活结点进行评估，如果边界函数小于目前叶子的边界值（就是实际路径长度），则该活节点继续留在活节点队列中，否则在队列中删除该节点。  
另外，如果图的邻接矩阵是非对称的，则对于每个城市我们取的是指向该城市最短的边和离开该城市的最短的边，作为边界函数的基本累加单元
## 状态空间树的其他优化方法
随机或者根据一定数据特性生成的可行解作为初始解，然后利用额外信息加速求解（比如棋盘的对称性）
## 分支界限法的最优输入
这里以分配问题为例。明显的一个例子是分配矩阵所有元素相等，这时候的状态空间树每一层只需要展开一个节点，即第一层是n个节点，然后展开一个，则第二层是n-1个节点，故而总共是$ sum_{i=0}^{n-1} (n-i) $个节点
# NP困难问题的近似解法
np难问题，指的是至少和npc问题一样难的问题,一般npc问题的优化版本（在普通组合问题基础上还要做最优化）就是这样的问题。对于组合最优问题我们可以采用近似方法快速求解。需要注意的是，可以互相转换的问题可能一个对某个近似算法好用，另一个对该算法却不好用
## c近似算法
首先对于近似解精确度的定义是近似解/精确解（最小化问题，最大化问题是其倒数）；c近似算法是指对某问题的**所有实例**都满足精确度小于等于c的算法。
## 旅行商问题的近似解
可以通过反证法证明，n=np时才c近似解法；大致证明过程通过构造图，旅行商近似解法来精确求解哈密顿回路问题（判定问题），具体可见课本；所以对于旅行商问题不存在c近似算法，该算法除了简单很难保证准确性
* 贪婪算法
** 最近邻居算法
任选城市开始，重复以下步骤直到访问完所有城市：访问与最近访问的城市k最接近的城市的未访问城市（如果有距离相等的城市可任选其一）；最后回到开始城市。
** 多片段启发式算法
将边按照权重升序进行排序，重复以下步骤直到获得一条节点数为n的路径：将排序列表中的下一条边加入不会使得某个顶点的连通度为3，也不会产生一条长度小于n的回路，否则忽略该边（和prim算法很像）
*** 欧几里得实例和tsp贪婪算法
欧几里得实例满足：两个点之间的边权重小于途径另外一个点的两个边的权重之和；对称性，distance[i,j]=distance[j,i]。对于这样的实例可以证明对于n>=2的情况下精确率不大于1/2*((log_2_n)+1)
* 基于最小生成树的近似算法
先得到一个最小生成树，然后从任意一个顶点开始，绕着这棵树散步一周（可以用dfs遍历，这个实现可能没有这个词看起来那么简单），记录经过的顶点；扫描第二步中得到的顶点列表从中消去所有重复出现的顶点，但留下在列表末尾的起始顶点不要消去以形成回程的捷径，余下的顶点就构成了一条哈密顿回路；可以证明对于欧几里得实例这个方法得到的路径小于2倍最优路径，所以对于该类型这是一个2近似算法
* chiristofides算法
因为绕树两周的时候每条边都只遍历一次，所以之前绕树算法中绕树两周得到的是一个欧拉回路
* 本地查找启发法
* 经验分析结果
## 背包问题的近似算法
* 背包问题的贪婪算法：价值重量比结合价值排序
* 近似方案
# 解非线性方程组的算法
* 二分法
* 试位法
* 牛顿法
