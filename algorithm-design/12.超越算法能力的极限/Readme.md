# 回溯法
其实就是有剪枝条件的DFS,可以用递归实现
## 相关例子
* 状态空间树（参见书上图12.2）
* 提前剪枝再回溯，重点是提前，避免了过大的解空间
* n 皇后问题
* 哈密顿回路的生成
* 子集和问题的求解
每个元素在不在集合中可以产生一次分叉，然后可以根据目前总和是否大于题目要的和或者剩下元素加起来是否小于题目要的和进行剪枝
## 一般性说明
* 通用模板dfs的递归实现
```cpp
Void BackTrace(int* s,int i) 
{
   if s从1到i是一个解 
      记录s
   else for s_i+1每一个可行解x
         s[I+1]=x;
         BackTrace(S, I+1);
}
```
注意以上实现没有考虑一条路径上节点前后互相的影响，这时候还需要加一个状态的复位
* 减枝技巧：棋盘对称减半(N皇后,这个对称可以按行列或者两个对角线)，预排序(子集和)，设置合理初始值(哈密顿回路)等
## 状态空间树规模的统计
c_0+c_0*c_1+...+c_0*c_1*c_n
c_0为1一般，c_i是随机选择的状态x_i-1对应的可能选择数。整体而言，回溯更适合优化问题，因为这种问题更容易剪枝
## n皇后问题的线性算法
属于根据图形找规律了，缺乏通用性,可以找答案看看这里不总结
## 回溯法的其他几个例子
* 对一个图求三色问题，要求邻接点不同色，则我们可以按一定顺序，每一层是某个点的几个可选的颜色状态，进行回溯法的遍历
* 回溯法生成排列
```cpp
A[100];
Vis[100];
void BackTrace(int* A, int i ,into* Vis) 
{
   if (i == n-1) {
      for (int k = 0; k < n; k++) {
          cout << A[k];    
      } 
      cout << endl;
      return;
   }
   for (int k = 0; k < n; k++) {
      if (Vis[k+1] == 0) {
          A[i] = k+1;
          Vis[k+1] = 1;
          BackTrace(A, i+1,Vis);
          A[i] = 0; //这个算回溯这个名字的由来了
          Vis[k+1] = 0;
      } 
}
```
# 分支界限法
分支界限法相比回溯法关注的主要是优化问题,因此在实现上，分支界限法会根据一些最优的标准来选择优先遍历的分支，不是像dfs总是找最近的遍历,更具体的说它是类bfs的，每一层都要先加入队列，然后根据边界选择分支;相比回溯法，分支界限法需要两个额外的条件：1.对于一课状态空间树的每一个节点所代表的部分解，我们要提供一种方法，计算出这个部分解繁衍出的任何解在目标函数上的最佳值边界（目前状态下理论最优值）2.目前求得的最佳解的值。简而言之，是利用边界函数更新下（上）界，根据下（上）界选择最优解，找到可行解后，对劣于最佳解的分支进行剪枝。
## 分配问题
首先是选出全局的下界，就是每个成员的最小完成成本之和，虽然不一定是可行的；然后再对每一个人可能的任务安排进行选择，然后针对每一个选择更新下界；然后选择下界最优的进行进一步的安排；以此循环之后，生成第一个完整序列后，得到目前最优成本，目前所有叶子节点的下界进行筛选，理论最优成本大于现有最优值的停止遍历，其他的继续遍历直到得到最优的结果。
## 背包问题
对于物品i,按照物品状态价值上届ub = V+(W-w)*(v_i+1/w_i+1)来进行遍历路径的优先选择,V是目前所有物品的价值，w是重量，W是总承重量，i+1要选择v_i+1/w_i+1最大的；对于每一件物品，有包含与不包含两种状态，每个物品的每种状态都进行ub的更新；剪枝的条件是：1.物品超过承重 2.ub小于目前最优ub
### 背包问题的边界函数的优化
我们可以把ub改成按v/w排序的物品，依次放入背包，直到一个物品放不下，把该物品的部分放入以刚好达到承重，此时书包内的物品的价值就是边界值
## 旅行商问题
首先旅行商问题是完全图，所以对于从b到c的路径，反过来就是从c到b的路径，所以我们在遍历时可以只考虑先b后c的路径；在遍历时出队的优先级由边界函数确定，边界函数的计算方法这里选择用所有城市相连的两条最短边长度累加起来再除以2，如果部分路径已经确定则对每个城市使用确定边和最小边的距离之和再除以2，这个函数显然就是目前能够得到的路径最短距离了（虽然不一定是可行的）。根据此函数给定的优先级进行遍历，在达到叶子节点后，对目前的活结点进行评估，如果边界函数小于目前叶子的边界值（就是实际路径长度），则该活节点继续留在活节点队列中，否则在队列中删除该节点。  
另外，如果图的邻接矩阵是非对称的，则对于每个城市我们取的是指向该城市最短的边和离开该城市的最短的边，作为边界函数的基本累加单元
## 状态空间树的其他优化方法
随机或者根据一定数据特性生成的可行解作为初始解，然后利用额外信息加速求解（比如棋盘的对称性）
## 分支界限法的最优输入
这里以分配问题为例。明显的一个例子是分配矩阵所有元素相等，这时候的状态空间树每一层只需要展开一个节点，即第一层是n个节点，然后展开一个，则第二层是n-1个节点，故而总共是$ sum_{i=0}^{n-1} (n-i) $个节点
# NP困难问题的近似解法
np难问题，指的是至少和npc问题一样难的问题,一般npc问题的优化版本（在普通组合问题基础上还要做最优化）就是这样的问题。对于组合最优问题我们可以采用近似方法快速求解。需要注意的是，可以互相转换的问题可能一个对某个近似算法好用，另一个对该算法却不好用
## c近似算法
首先对于近似解精确度的定义是近似解/精确解（最小化问题，最大化问题是其倒数）；c近似算法是指对某问题的**所有实例**都满足精确度小于等于c的算法，c的最小值称为性能比。
## 旅行商问题的近似解
可以通过反证法证明，n=np时才c近似解法；大致证明过程通过构造图，旅行商近似解法来精确求解哈密顿回路问题（判定问题），具体可见课本；所以对于旅行商问题不存在c近似算法，该算法除了简单很难保证准确性
* 贪婪算法
   - 最近邻居算法
任选城市开始，重复以下步骤直到访问完所有城市：访问与最近访问的城市k最接近的城市的未访问城市（如果有距离相等的城市可任选其一）；最后回到开始城市。
   * 多片段启发式算法
将边按照权重升序进行排序，重复以下步骤直到获得一条节点数为n的路径：将排序列表中的下一条边加入不会使得某个顶点的连通度为3，也不会产生一条长度小于n的回路，否则忽略该边（和prim算法很像）
* 欧几里得实例和tsp贪婪算法
欧几里得实例满足：两个点之间的边权重小于途径另外一个点的两个边的权重之和；对称性，distance[i,j]=distance[j,i]。对于这样的实例可以证明对于n>=2的情况下精确率不大于1/2*((log_2_n)+1)
   * 基于最小生成树的近似算法
先得到一个最小生成树，然后从任意一个顶点开始，绕着这棵树散步一周（可以用dfs遍历，这个实现可能没有这个词看起来那么简单，而且绕的路径不同得到的路径长度也不同），记录经过的顶点；扫描第二步中得到的顶点列表从中消去所有重复出现的顶点，但留下在列表末尾的起始顶点不要消去以形成回程的捷径，余下的顶点就构成了一条哈密顿回路；可以证明对于欧几里得实例这个方法得到的路径小于2倍最优路径，所以对于该类型这是一个2近似算法
   * chiristofides算法
因为绕树两周的时候每条边都只遍历一次，所以之前绕树算法中绕树两周得到的是一个欧拉回路。  
这个算法的具体步骤是通过把最小生成树中连通度为奇数的点留下来，由于这种点数目总是偶数，可以得到其权重和最小的匹配（一对一连接为一条边叫匹配，非匹配的点不连接），把最小权重匹配边加入最小生成树的图中，可以得到一个每个点具有偶数连通度的图，因为偶数连通度意味着欧拉回路存在，然后就可以得到一条欧拉回路，再对其中重复点进行删除（除了起点的重复）（所谓走捷径），便得到一个近似解。这个算法比前几种精确度高
* 本地查找启发法
其实也是迭代改进思想的应用，首先用比较简单的算法生成一个初始解，然后：2选算法删除旅途中的一对非邻接边，然后把这两条边对应顶点用令两条不会使整个旅途一分为二的边连接起来以查看是否得到了优化；k选算法顾名思义，但是实际上只有3选算法是有实际意义的；还有Lin-Kernighan算法是一种变选算法，3选后跟着一系列的2选算法
* 经验分析结果
held-karp下界是对于该问题的一个估计和精确解差异小于1%，非对称实例相比欧几里得实例求解效率很低
## 背包问题的近似算法
* 背包问题的贪婪算法：按照价值重量比进行降序排序，能放进书包放进去，放不进去的下一个，这显然是一个比较粗暴的近似方法，可以选择进一步优化；但是这个策略对于连续版本的是个精确解，可以对离散版本的分支界限法作为边界函数。
* 近似方案
萨尼近似方案：0<=k<=n,先生成k个物品的子集然后按照贪婪算法添加物品，精确率为1+1/k；还有更加的复杂的完全多项式方案
## 设计2近似算法求最小的顶点覆盖
顶点覆盖的定义可能首先就不够直观：图的所有点的一个子集，图中的每个边至少有一个顶点包含在该点集中，称该点集为该图的一个顶点覆盖，可以理解为用点去覆盖边，最小的就是用最少的点覆盖边；近似算法如下：将顶点覆盖初始化为空集。 重复以下操作直到没有剩余边：选择任意边，将其两个端点添加到顶点覆盖，并从图中删除与这两个端点顶点中的任何一个相关的所有边；显然这个算法最后留下的是没有共同点的一组边，假设其数量为k; 对于精确的最小顶点覆盖肯定包含每条边中其中一个点，所以精确解点数大于等于k,该算法返回的解是2k,则说明是一个2近似算法  
输出以上算法的结果的在图中的补集，作为最大独立集(图的点子集中的点没有相连的）的近似是不合适的，如果对于最大匹配出来的图，其最大独立集显然包含了所有点，用该算法得到的却是0个点，误差极大
## 图的着色问题的近似贪婪算法
检查某个点所有相邻点是否有目前最新的color,如果没有则给它该color,否则color+1(color预先排好序）再检查其相邻点；依然是对于最大匹配的图，这个算法会给出n种颜色，而实际两种颜色就够了
# 解非线性方程组的算法
* 二分法
* 试位法
* 牛顿法
