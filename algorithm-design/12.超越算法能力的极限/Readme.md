# 回溯法
其实就是有剪枝条件的DFS,可以用递归实现
## 相关例子
* 状态空间树（参见书上图12.2）
* 提前剪枝再回溯，重点是提前，避免了过大的解空间
* n 皇后问题
* 哈密顿回路的生成
* 子集和问题的求解
每个元素在不在集合中可以产生一次分叉，然后可以根据目前总和是否大于题目要的和或者剩下元素加起来是否小于题目要的和进行剪枝
## 一般性说明
* 通用模板dfs的递归实现
```cpp
Void BackTrace(int* s,int i) 
{
   if s从1到i是一个解 
      记录s
   else for s_i+1每一个可行解x
         s[I+1]=x;
         BackTrace(S, I+1);
}
```
注意以上实现没有考虑一条路径上节点前后互相的影响，这时候还需要加一个状态的复位
* 减枝技巧：棋盘对称减半(N皇后,这个对称可以按行列或者两个对角线)，预排序(子集和)，设置合理初始值(哈密顿回路)等
## 状态空间树规模的统计
c_0+c_0*c_1+...+c_0*c_1*c_n
c_0为1一般，c_i是随机选择的状态x_i-1对应的可能选择数。整体而言，回溯更适合优化问题，因为这种问题更容易剪枝
## n皇后问题的线性算法
属于根据图形找规律了，缺乏通用性,可以找答案看看这里不总结
## 回溯法的其他几个例子
* 对一个图求三色问题，要求邻接点不同色，则我们可以按一定顺序，每一层是某个点的几个可选的颜色状态，进行回溯法的遍历
* 回溯法生成排列
```cpp
A[100];
Vis[100];
void BackTrace(int* A, int i ,into* Vis) 
{
   if (i == n-1) {
      for (int k = 0; k < n; k++) {
          cout << A[k];    
      } 
      cout << endl;
      return;
   }
   for (int k = 0; k < n; k++) {
      if (Vis[k+1] == 0) {
          A[i] = k+1;
          Vis[k+1] = 1;
          BackTrace(A, i+1,Vis);
          A[i] = 0; //这个算回溯这个名字的由来了
          Vis[k+1] = 0;
      } 
}
```
# 分支界限法
分支界限法相比回溯法关注的主要是优化问题,因此在实现上，分支界限法会根据一些最优的标准来选择优先遍历的分支，不是像dfs总是找最近的遍历;相比回溯法，分支界限法需要两个额外的条件：对于一课状态空间树的每一个节点所代表的部分解，我们要提供一种方法，计算出这个部分解繁衍出的任何解在目标函数上的最佳边界
状态空间树更新下（上）界，根据下（上）界选择最优解，找到可行解后全局更新下（上）界；边界时具有实际约束力的目标函数；额外信息加速求解；随机或者根据一定数据特性生成的可行解作为初始
## 分配问题

## 背包问题
ub = V+(W-w)*(v_i+1/w_i+1)
## 旅行商问题
# NP困难问题的近似解法
## 旅行商问题的近似解
可以通过反证法证明，n=np时才有多项式时间内的近似解法；证明过程通过构造图，旅行商近似解法来精确求解哈密顿回路问题。
* tsp贪婪算法
* 基于最小生成树的算法
* chiristofides算法
* 本地查找启发法
* 经验分析结果
## 背包问题的近似算法
* 背包问题的贪婪算法：价值重量比结合价值排序
* 近似方案
# 解非线性方程组的算法
* 二分法
* 试位法
* 牛顿法
