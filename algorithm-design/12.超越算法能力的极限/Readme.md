# 回溯法
其实就是有剪枝条件的DFS,可以用递归实现
## 相关例子
* 状态空间树（参见书上图12.2）
* 提前剪枝再回溯，重点是提前，避免了过大的解空间
* n 皇后问题
* 哈密顿回路的生成
* 子集和问题的求解
每个元素在不在集合中可以产生一次分叉，然后可以根据目前总和是否大于题目要的和或者剩下元素加起来是否小于题目要的和进行剪枝
## 一般性说明
* 通用模板dfs的递归实现
```cpp
Void BackTrace(int* s,int i) 
{
   if s从1到i是一个解 
      记录s
   else for s_i+1每一个可行解x
         s[I+1]=x;
         BackTrace(S, I+1);
}
```
注意以上实现没有考虑一条路径上节点前后互相的影响，这时候还需要加一个状态的复位
* 减枝技巧：棋盘对称减半(N皇后,这个对称可以按行列或者两个对角线)，预排序(子集和)，设置合理初始值(哈密顿回路)等
## 状态空间树规模的统计
c_0+c_0*c_1+...+c_0*c_1*c_n
c_0为1一般，c_i是随机选择的状态x_i-1对应的可能选择数。整体而言，回溯更适合优化问题，因为这种问题更容易剪枝
## n皇后问题的线性算法
属于根据图形找规律了，缺乏通用性,可以找答案看看这里不总结
## 回溯法的其他几个例子
* 对一个图求三色问题，要求邻接点不同色，则我们可以按一定顺序，每一层是某个点的几个可选的颜色状态，进行回溯法的遍历
* 回溯法生成排列
```cpp
A[100];
Vis[100];
void BackTrace(int* A, int i ,into* Vis) 
{
   if (i == n-1) {
      for (int k = 0; k < n; k++) {
          cout << A[k];    
      } 
      cout << endl;
      return;
   }
   for (int k = 0; k < n; k++) {
      if (Vis[k+1] == 0) {
          A[i] = k+1;
          Vis[k+1] = 1;
          BackTrace(A, i+1,Vis);
          A[i] = 0; //这个算回溯这个名字的由来了
          Vis[k+1] = 0;
      } 
}
```
# 分支界限法
分支界限法相比回溯法关注的主要是优化问题,因此在实现上，分支界限法会根据一些最优的标准来选择优先遍历的分支，不是像dfs总是找最近的遍历,更具体的说它是类bfs的，每一层都要先加入队列，然后根据边界选择分支;相比回溯法，分支界限法需要两个额外的条件：对于一课状态空间树的每一个节点所代表的部分解，我们要提供一种方法，计算出这个部分解繁衍出的任何解在目标函数上的最佳边界
状态空间树更新下（上）界，根据下（上）界选择最优解，找到可行解后全局更新下（上）界；边界时具有实际约束力的目标函数；额外信息加速求解；随机或者根据一定数据特性生成的可行解作为初始
## 分配问题
首先是选出全局的下界，就是每个成员的最小完成成本之和，虽然不一定是可行的；然后再对每一个人可能的任务安排进行选择，然后针对每一个选择更新下界；然后选择下界最优的进行进一步的安排；以此循环之后，生成第一个完整序列后，目前所有叶子节点的下界进行筛选，不可行的停止遍历，大于最优值的停止遍历，其他的继续遍历直到得到最优的结果。
## 背包问题
对于物品i,按照物品状态价值上届ub = V+(W-w)*(v_i+1/w_i+1)来进行遍历路径的优先选择,V是目前所有物品的价值，w是重量，W是总承重量，i+1要选择v_i+1/w_i+1最大的；对于每一件物品，有包含与不包含两种状态，每个物品的每种状态都进行ub的更新；剪枝的条件是：1.物品超过承重 2.ub小于目前最优ub
## 旅行商问题
首先旅行商问题是完全图，所以对于从b到c的路径，反过来就是从c到b的路径，所以我们在遍历时可以只考虑先b后c的路径；在遍历时出队的优先级由边界函数确定，边界函数的计算方法这里选择用所有城市相连的两条最短边长度累加起来再除以2，如果部分路径已经确定则对每个城市使用确定边和最小边的距离之和再除以2，这个函数显然就是目前能够得到的路径最短距离了（虽然不一定是可行的）。根据此函数给定的优先级进行遍历，在达到叶子节点后，对目前的活结点进行评估，如果边界函数小于目前叶子的边界值（就是实际路径长度），则对该活节点继续留在活节点队列中，否则在队列中删除该节点。
# NP困难问题的近似解法
## 旅行商问题的近似解
可以通过反证法证明，n=np时才有多项式时间内的近似解法；证明过程通过构造图，旅行商近似解法来精确求解哈密顿回路问题。
* tsp贪婪算法
* 基于最小生成树的算法
* chiristofides算法
* 本地查找启发法
* 经验分析结果
## 背包问题的近似算法
* 背包问题的贪婪算法：价值重量比结合价值排序
* 近似方案
# 解非线性方程组的算法
* 二分法
* 试位法
* 牛顿法
