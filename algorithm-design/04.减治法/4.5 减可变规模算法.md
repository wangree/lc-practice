# 4.5.1 计算中值和选择问题
LumutoPartition算法（与荷兰国旗法具有同样的思想）
算法的步骤：第一个元素为中轴，index赋给s,i从第二个元素开始遍历，如果遇到小于中轴元素的I,给s+1并交换i上元素和加1后的s(总能够保证s<I)一直遍历到i结束，返回最后的s
在头尾堆积元素，并辅以交换使得划分以O(n)时间完成
# 4.5.2 插值查找 比折半查找更快，插值查找的平均效率是log2(log2n+1) 最差O(n)
# 4.5.3 二叉查找树的查找和插入
二叉查找树的形状与其构造时键的插入顺序有关
平均效率O(logn),最差效率O(n)
查找和插入效率相似
# 4.5.4 拈游戏
拿走最后一个棋子的人获胜，一次可以拿1到m个棋子；
如果实例是1到m个，则一定获胜；
m+1是必败的局面，因为你无论拿走几个棋子，剩下的对方都可以一次拿完；
m+1的n倍也是必败局，因为无论你拿走几个，对方走一步都可以让你剩下n-1倍m个棋子，依次相似策略直到剩下m+1个棋子给你
所以问题转化为怎么让对方只剩m+1的整数倍个棋子，所以制胜吧策略就是拿走m mod(n+1)个
每次通过取n mod(m+1)个棋子总能使对方陷入必败的局面，这是由1<=n<=m一直正推到m+1的数倍得出的结论
### 另类拈游戏
对于习题中的另类拈游戏，首先m+2和1是必败局面，m+2对先手不论拿几个，后手都可以一次让你只剩下1个，即一个完整的回合拿走m+1个，这里的m+1就是关键而不是m+2因为m+2不是完整回合，所以如果是n mod(m+1)为1时，后手可以控制每完整回合拿走m+1个送给先手必败局
因此总结一下，这类游戏先找到一种通用的必败(一般是后手控制先手使得完整回合拿走一个固定的值)局面(一个数列)，然后就会有必胜局面
## 拈游戏的一般版本
有I堆棋子，每堆棋子的数量不同，每次每个人可以从一堆棋子中拿走任意数量的棋子，最终的解法是各堆棋子的二进制数相加且不进位之和中有位模式中有一个1则对于先手是胜局，这时候对于先手来讲就是拿走一些棋子让其和二进制为全0,就给对手必败局
## 习题
```
 a. Algorithm Quickselect([0 − 1] )
//Solves the selection problem by partition-based algorithm
//Input: An array [0 − 1] of orderable elements and integer  (1 ≤
 ≤ )
//Output: The value of the kth smallest element in [0 − 1]
 ←
0;
 ←

− 1

[]
← ∞
//append sentinel
while
 ≤

do
 ←

[
]
//the pivot

← ;  ←  + 1
repeat
repeat  ←  + 1 until [] ≥ 
repeat

←  − 1 until [] ≤  do
swap([] 
[])
until  ≥

swap([
] 
[]) //undo last swap
swap([] []) //partition
if  − 1  ←

− 1
else if  −
1
 ←  + 1
else return 
[ − 1]
```
### 如何运用减可变规模的方法得到一个偶数度图的欧拉回路
首先从任意点开始遍历并得到一个回路(保证不会遍历一个边两次以及可以到达的都已经被遍历)得到一个回路c，这个回路c一定是个欧拉回路，再对剩下的子图g从g和c的连接点开始进行递归计算得到和回路g1和c拼接在一起就是一个完整的欧拉回路
无路可走的情况：https://blog.csdn.net/weixin_35033082/article/details/112103258
#### 欧拉回路详细定义和fluery算法
https://blog.csdn.net/p011235/article/details/48770327


