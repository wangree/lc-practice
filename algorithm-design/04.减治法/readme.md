# 4.1 插入排序
插入排序应用了减治法(具体来说是减1）的思想，是对某个数字a[i],之前的有序序列进行插入，所以i从1开始；由于其键值平均比较次数约为n^2/4,最优为O(n),性能优于选择排序和冒泡排序
## 习题4.1
### 减一思想很适合生成子集，生成n-1的子集和多出的一个1，以及1和n-1所有子集的组合
### 给定一个完全循环赛的结果，然后对多个队伍进行排序，要求前面的队伍没有输过后面的队伍
这个虽然也是减1的思路，但是不适合用递归；实际上应该用类似插入排序的思路，需要从头到尾查看是否赢过该队再插入在该队之前，或者从右向左直到找到第一个它输过的球队，插到该队之后
### 插入排序平均效率的推导
我们假定对于元素i,对于限位器版本，它有i+1个位置可以插入，这个i+1的位置插入概率是相同的，则我们有$$ 1/(i+1)*\sum_{j=1}^{i+1} j = \frac {i+2}{i} $$,则对于所有的i我们可以得到
$$ exp=\sum_{i=1}^{n-1} \frac{i+2}{i} \approx \frac {n^2}{4} $$ 
### 希尔排序
以大步长进行插入排序（进行原地的赋值和插入，各步长之间不影响）做到基本有序，最后再以1步长得到最终结果，希尔排序是不稳定的，插入排序稳定，具体算法实现见附上的源码
# 4.2 拓扑排序
## 有向图
回边 交叉边 树向边 前向边 对于无向图来说dfs是不可能有交叉边的 对于有向图这几种边的解释请见：https://blog.csdn.net/C_ZhangSir/article/details/98238664
## 实现原理
一种是dfs出栈顺序反过来，就是拓扑排序的结果；一种是利用减1的思想，不停的求出源也就是degree为0的点，再删除它，再循环进行，删除的次序就是拓扑排序的结果
## 习题4.2
### 证明有向图无环才有解
假定一个解是$v_1,v_2,...,v_n$,并且有环，如果$v_k$是该环中元素最左侧的，但是根据环的形状，一定会有元素在它的左侧，矛盾
### 证明无环有向图必有一个源
反证法，如果无源则每个点都有一个入边，将入边反过来变成出边，则因为每个都有出边，则我们对于任意一个点，要么它会指向已经某条路径的前趋之一，要么会指向还没有遍历过的点，而这个没有遍历过的点沿着路径还是会指向一个已经遍历过的点，形成环，故矛盾
### 强连通分量
有向图中，存在互相访问路径的点的子集，寻找强连通分量的算法：1.dfs遍历并按照出栈顺序进行编号  2.颠倒所有边的方向  3.再进行一次dfs遍历，这次从编号最大的没有访问过的点开始
### 蛛网路径问题
![image](https://user-images.githubusercontent.com/46526327/136352803-bedf76ff-1b69-4694-8191-a4972c81518e.png)  
一只蜘蛛位于网的底端(S)，而一只苍蝇位于网的顶端(F)。沿着箭头方向在线上移动，蜘蛛有多少不同的路径到达苍蝇处？  
从S出发按照拓扑排序的顺序依次遍历节点，对每个节点计算从S出发到达它存在多少路径，计算方法是对所有前驱节点的路径数求和。计算得到到达F节点的路径数是141。  
![image](https://user-images.githubusercontent.com/46526327/136354993-3cb9f0af-57ed-4716-9e2e-a4346a0e1f10.png)  
从此题书上的答案来看，书上每次在删除一个源后，会立即将新源加入，然后给源的队列按照字母顺序排序，从字母最小的开始再进行删源，可以说，这是一般的搜索的模式，既不是bfs也不是dfs,是更一般的根据自己需求产生的搜索遍历形式
