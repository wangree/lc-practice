# 二分查找
二分查找非递归的思路总结，首先左右是第一个元素和最后一个元素的下标，判断中间元素(向0舍入下标),根据结果改变左右其中之一，如果序列中没有这个值会出现跨越，即左大于右的情况
# 寻找假币(二分查找的引申)
二分找假币并不是最好的办法，三分效率更高
# 俄式乘法
仅仅使用折半，加倍和加法来计算乘法，二分思想的引申
# 约瑟夫斯问题
本书是报数报到2就会被杀掉。每杀掉一个人，从其右侧开始重新报数
对于奇数人次和偶数人次，书本上提出了两种递推关系，而我们知道总人数为1时，幸存者肯定是1，故而可以给约瑟夫问题的公式，书本上也给出了一个利用二进制循环移位的结果。
更加普适和容易理解的问题描述：n个人（编号0~(n-1）），从0开始报数，报到（k-1）的退出，剩下的人继续从0开始报数。求胜利者的编号。
我们知道第一个人（编号一定是（k-1）) 出列之后，剩下的n-1个人组成了一个新的约瑟夫环（以编号为k的人开始）：
* k k+1 k+2 ... n-2,n-1,0,1,2,... k-2
并且从k开始报0。
我们把他们的编号做一下转换：
* k --> 0
* k+1 --> 1
* k+2 --> 2
* ...
* ...
* k-2 --> n-2
变换后就完完全全成为了（n-1）个人报数的子问题，假如我们知道这个子问题的解：例如x是最终的胜利者，那么根据上面这个表把这个x变回去不刚好就是n个人情况的解吗？！！变回去的公式很简单，相信大家都可以推出来：x'=(x+k) mod n
如何知道（n-1）个人报数的问题的解？对，只要知道（n-2）个人的解就行了。（n-2）个人的解呢？当然是先求（n-3）的情况 ---- 这显然就是一个倒推问题！好了，思路出来了，下面写递推公式：
令f表示i个人玩游戏报m退出最后胜利者的编号，最后的结果自然是f[n]
递推公式
* f[1]=0;
* f[i]=(f[i-1]+m) mod i; (i>1）
有了这个公式，我们要做的就是从1-n顺序算出f的数值，最后结果是f[n]。因为实际生活中编号总是从1开始，我们输出f[n]+1
由于是逐级递推，不需要保存每个f，程序也是异常简单

以上分析不错，比书上的更加透彻，这个问题其实更适合用减常量法的思路而不是减常因子的思路来做，根据以上思路写代码如下：
```cpp
int josephus(int n,int baoshu){
    int now=0;
    for (int i = 1; i <= n ; ++i) {
        now=(now+baoshu)%i;
    }
    return now+1;
}
int main(){
    int res=josephus(6,2);
    return 0;
}
```
当然也可以写成递归，但是感觉毫无必要。

