本章主要针对图算法
# 单纯形法
该方法是线性规划解法的非蛮力程序化方法，因为原理不太清楚，算法执行也不算简单，这里只写几个关键词：单纯形表，基本解，非基本解，输入变量，主元列，
分离变量，主元行（这两者在下一张表格互换），这些变量也涵盖了4步的算法。
若m和n是约束等式和变量的数量，算法的迭代次数在m和3m之间，迭代次数与mn成正比，建议后面可不再看
# 最大流量问题
该方法是贪婪和bfs及迭代改进思想的综合，大致思路是用源点初始化队列，pop出front来作为队首，找i可以未标记的前向边点（剩余流量大于0）和后向边点（流量大于0），按次序加入队列，然后pop队首，如此循环，直到汇被标记，汇被标记后从队尾进行流量增益，对于有前向点标记的减去流量,对于有后向点标记的加上流量，每个点的当前流量会被记录下来，增益结束后清空源点外的标记，并初始化队列为只有源和其初始标记，接着再进行队列的bfs循环，直到队列内pop至空。
## 最大流-最小割定理 感觉较难理解
# 二分图的最大匹配
## 一些匹配的概念
* 增益路径
* 不饱和点（自由顶点）
* 偶图/交替路径
* 匹配/完美匹配/最大匹配
## 贝尔热定理的证明
* 该定理是当且仅当匹配M不存在增益路径时，M是最大匹配
* 可以通过证明其逆否命题：M不是最大匹配，M存在增益路径，反证法M非最大匹配,假设不存在增益路径。如果M非最大匹配，设M<sup>+</sup>为最大匹配，则M与M<sup>+</sup>的对称差要么是偶图（M中的边和 M<sup>+</sup> 中的边各占一半），要么是交替路径（奇数），由于 M<sup>+</sup> ，则一定有交替路径出现才行，并且起点路径和终点路径必然都在 M<sup>+</sup> 中(和原图G没有关系），因而我们发现了一条增益路径，假设不成立
## 二分图寻找最大匹配的算法
* 根据以上定理，最关键的还是如何寻找增益路径
* 一次匹配开始，从自由顶点出发的bfs将能够连接到的点匹配了一遍后，已经找遍了所有能够进行增益的路径，因为bfs不会有所遗漏，所以认为找不到增益路径了，所以就是最大匹配
### bfs寻找最大匹配算法(伪代码）
```cpp
Q={自由顶点}
M;//匹配
while(Q!=empty()){
   v=Q.front();
   Q.pop();
   if(v属于V){
       for(vv:v的邻接点）{
       if(vv已经匹配 && vv未标记）{
          vv标记为v;
          Q.push(vv);
          }
       else if(vv是自由顶点）//进行增益{
          M.push_back((v,vv));
          while(v被标记）{
              v_pre=v的标记点；
              M.erase((v_pre，v));
              v=v_pre标记的点；
              M.push_back((v,v_pre));
          }
          抹去所有顶点的标记；
          用目前的所有自由顶点初始化Q;
       }
       }
    }
    else{
        v_next=v的匹配点;
        v_next标记为v;
        Q.push(v_next);
        }
}
return M;
```
## 稳定婚姻问题
相对比较简单，注意性别倾向性
