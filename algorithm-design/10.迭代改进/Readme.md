本章主要针对图算法
# 单纯形法
## 极点定理 
可行区域非空的任意线性规划问题有最优解，而且，最优解总是能够在可行区域的一个极点上找到  
## 一般步骤
1.初始化：首先是将问题转换为标准形式，所有变量都必须是非负的，必须是一个最大化问题，不等式约束利用松弛因子转换为等式，假设我们得到的是m个n元方程组成的方程组；将其中n-m个变量置为0，化为m个m元方程组，在对应矩阵满秩时就得到了一个基本解，设为0的那些就认为是非基本的；如果一个基本解的所有坐标值都为非负则该基本解被称为基本可行解;表现在单纯形表上就是建立一个初始表，它的最右列的单元格都是非负的，接下来的m列组成了一个m x m的单位矩阵（目标行的单元格不必满足这一条件，目标行是目标函数的相反数对应的系数向量，非零值均为负数，将它们划为0代表目标行最右侧）（这种做法解释一下就是提取出线性方程组中共有的设为0，其他设为1，因为松弛因子的特殊性，所以它是每个方程独有的，故而形成了一个单位阵，保证了松弛因子根据方程解出的值非负）。这m列确定了初始的基本可行解的基本变量，而表格中的行用基本变量来标识  
2.最优测试：如果目标行中所有单元格都是非负的（除了最右列），就可以停止了：该表格代表的是一个最优解，它的基本变量的值在最右列中（因为对于基本变量是单位阵，所以尽管和行对齐但是它可以代表基本变量的值），而剩下的非基本变量的值是0。(为什么目标列最右是目标函数值，可能因为每次用主元行消去输入变量的系数时顺便会把系数*输入变量累加到目标列最右元素）  
3.确定输入变量：从目标行的前n个单元格选择一个非零单元格（一般选择绝对值最大的那个负单元格，使得新的基本变量对目标函数的提升是最大的），该单元格所在的列确定了输入变量和主元列，输入变量是新的基本变量  
4.确定分离变量：对于主元列上的每个正单元格，将其所在行最右单元格除以主元列的单元格，求得一个$\theta$比率，找出$\theta$比率最小的行（$\theta$的意思就是将某个基本变量变为0的减少量与新新基本变量的提升系数之比，这个值越小代表对目标函数的提升越大），（如果主元列没有正单元格则该问题无界），该行确定了分离变量和主元行，主元行在生成下一张表时是用来消元的，分离变量在生成新表时会变成非基本变量  
5.建立下一张表格：将主元行中所有单元格除以主元（主元行和主元列相交的元素）得到新主元行（使输入变量的系数为1）并用它消去主元列对应的其他行系数，使得除了主元行，输入变量的系数都为0；然后把主元行前的标识用主元列的变量名代替，代表新的基本变量诞生  

单纯形法的最差效率是指数级的，若m和n是约束等式和变量的数量，算法的迭代次数在m和3m之间，迭代次数与mn成正比，建议后面可不再看

## 单纯形法与背包问题
背包问题的连续版本可以通过
单纯形法，因为它是一般线性规划问题的特例（参见第 6.6 节中的示例 2）。 然而，这并不是解决这个问题的好方法，因为它可以通过基于贪婪方法的更简单的算法来更有效地解决。 你可能想自己设计一个这样的算法，然后再在书中查找。
背包问题的 0-1 版本无法通过单纯形方法解决，因为问题的变量上施加了完整性 (0-1) 约束 
## 线性规划的其他问题
除非k=1,否则线性规划问题不可能具有k>=1个确定个数的解；我们可以通过反证法证明：线性规划问题的最优解集是凸的。 任何非空凸集可以包含单个点或无限多个点 
## 线性规划的对偶问题
![](https://github.com/wangree/lc-practice/blob/master/algorithm-design/10.%E8%BF%AD%E4%BB%A3%E6%94%B9%E8%BF%9B/Screenshot_20220103_120548_cn.wps.moffice_eng.jpg)
两者有相同的目标函数最优值
# 最大流量问题
该方法是贪婪和bfs及迭代改进思想的综合，大致思路是用源点初始化队列，pop出front来作为队首，找i可以未标记的前向边点（剩余流量大于0）和后向边点（流量大于0），按次序加入队列，然后pop队首，如此循环，直到汇被标记，汇被标记后从队尾进行流量增益，对于有前向点标记的减去流量,对于有后向点标记的加上流量，每个点的当前流量会被记录下来，增益结束后清空源点外的标记，并初始化队列为只有源和其初始标记，接着再进行队列的bfs循环，直到队列内pop至空。  
要总结的一点是，流量网络是有向图，每条边的流向已经确定，反向边也只能削弱流量
## 最大流-最小割定理或者叫最大流最小切分定理
切分或者割指的是将所有顶点分为两个不相交的集合，而一条横切边则是连接分别存在于两个集合中的两个顶点的一条边
i    存在某个s-t切分，其容量和其对应网络的流量相等；
ii   网络达到了最大流量；
iii  网络中已经不存在任何增广路径
以上三者是等价的，通过论证可以证明增广路径法的正确性。  
证明：根据命题 E 的推论，我们可以由条件 i 得到条件 ii。因为增广路径的存在意味着存在某个流量更大的网络配置，这与流量的最大性相冲突，因此由条件 ii 也可以得到条件 iii。
但还需要证明条件 iii 和条件 i 等价。令C_s为由s通过所有不含有任何饱和正向边或空逆向边的无向路径可达的所有顶点组成的集合，令C_t为其余的顶点的集合。 t必然存在于C_t中，因此(C_s,C_t)为一个s-t切分。它的切分集完全由饱和正向边和空逆向边组成。
该切分的跨切分流量和它的容量相等（因为所有正向边都是饱和的，而所有逆向边都是空的），即等于网络中的总流量（由命题 E ,对于任意st流量网络，每种st切分中的跨切分流量都和总流量的值相等。）。
## 算法效率
该算法的效率是O(EV^2/2),一条增广路径至少有一个关键边，所以我们可以用关键边数量来估计增广路径的个数，由于每条边能够成为关键边至少会让这个边某点到s的距离增加2(变了方向以后，自身长度加上就有2)，也就是路径长度增加2,而一条增广路径到最后最多长度是V,所以一条关键边最多会成为V/2次关键边(具体来说，这条边的某个点u,最极端情况下在一开始成为关键边时距离s为0,经过多次增广后由于路径长度最多为v-1,而它和s的距离最多为v-2,也就是说它距离终点t至少有1,所以它做关键边最多为V/2-1，所以经过它的增广路径最多有EV/2条，所以最终是EV^2/2,具体见https://www.cnblogs.com/uid001/p/10465580.html。  
此外还有其他算法，EK算法使用优先队列，先遍历能够使流量增大最多的路径，其效率为E^2logC,C为各边最大容量，预流推进法为EVlog(E/V^2)
## 多解性
最大流问题一般可能有多个解；最小割也是多解的，尽管解的数量有限
## 当有多个源和汇的时候的时候，如何转换为一个新的单源单汇问题
在给定的网络中添加两个顶点，分别作为新网络的源和汇。 将新源连接到每个原始源，将每个原始汇通过一些大容量为M 的边连接到新汇（取M大于或等于原始网络中汇出每个原始源的边的容量之和就足够了）
## 中间点有流量约束时的处理
![](https://github.com/wangree/lc-practice/blob/master/algorithm-design/10.%E8%BF%AD%E4%BB%A3%E6%94%B9%E8%BF%9B/Screenshot_20220106_185247_cn.wps.moffice_eng.png)
## 流量网络的巧妙应用
有P个家庭，q张桌子，要求每个家庭的成员不能坐在同一张桌子上，每个家庭成员数目为a_i,每个桌子容量为b_i,可以用最大流量算法求解
![](https://github.com/wangree/lc-practice/blob/master/algorithm-design/10.%E8%BF%AD%E4%BB%A3%E6%94%B9%E8%BF%9B/Screenshot_20220107_094002_cn.wps.moffice_eng.png)
#  二分图的最大匹配

## 一些匹配的概念
* 增益路径
指为奇数个数的交替路径，该回路中一条边不属于M,一条边属于M,直到最后一条边不属于M,而且起终点都是非饱和点
* 不饱和点（自由顶点）
* 偶图/交替路径
* 匹配/完美匹配/最大匹配
匹配 M--- 如果M是图G的边子集(不含环），且M中的任意两条边没有共同顶点，则称M是G的一个匹配或对集或边独立集。

* 如果G中顶点v是G的匹配 M中某条边的端点，称它为M饱和点，否则为M非饱和点。

* 最大匹配 M--- 如果M是图G的包含边数最多的匹配，称M是G的一个最大匹配。特别是，若最大匹配饱和了G的所有顶点，称它为G的一个完美匹配。

## 贝尔热定理的证明
* 该定理是当且仅当匹配M不存在增益路径时，M是最大匹配
* 可以通过证明其逆否命题：具体可见Wiki:https://en.m.wikipedia.org/wiki/Berge%27s_theorem
## 二分图寻找最大匹配的算法
* 根据以上定理，最关键的还是如何寻找增益路径
* 一次匹配开始，从自由顶点出发的bfs将能够连接到的点匹配了一遍后，已经找遍了所有能够进行增益的路径，因为bfs不会有所遗漏，所以认为找不到增益路径了，所以就是最大匹配
### bfs寻找最大匹配算法(伪代码）
```cpp
//该算法的结束条件是要么达到一个U中的自由顶点，要么搜索到了尽头
//把该算法的队列换成栈也是可以的
//有两个匹配集合一个是V,一个是U
Q={V中的自由顶点}
M;//匹配
while(Q!=empty()){
   v=Q.front();
   Q.pop();
   if(v属于V){
       for(vv:v的邻接点）{
           //代表交替路径中不属于属于原匹配M的路径，是vv的一条新路径
             if(vv已经匹配 && vv未标记）{
               vv标记为v,代表前继是v;
               Q.push(vv);
             }
             else if(vv是自由顶点）//进行增益{
             M.push_back((v,vv));
             while(v被标记）{
                  v_pre=v的标记点；
                  M.erase((v_pre，v));
                  v=v_pre标记的点；
                  M.push_back((v,v_pre));
             }
             抹去所有顶点的标记；
             用目前的所有自由顶点初始化Q;
             }
          }
    } else {
        //能加入到Q中的点，一定是先前匹配的，要么是在这里加入的，要么是在代码第一个if中加入的
        v_next=v的匹配点;
        //这代表交替路径中属于M的路径
        v_next标记为v;
        Q.push(v_next);
        }
}
return M;
```
该算法效率为O(n(n+m)),因为每次匹配都是v中的一个点和U一个点,所以匹配不会超过n/2+1次，每次查找增益路径最多会是n+m,n为所有点的个数，m为边的总数
### 对于有顶点集V和U各有n个点，并有至少有n条边的二分图
1.最大匹配数。  
最大匹配数应该是n,n条边每条边都对应一个匹配。最小匹配数是1，即为n从一个点出发的情况。  
2.最大匹配有多少种。  
对于V和U充分连接的图，共有n!中可能的最大匹配；对于仅有n条边并且每条边都对应一个匹配的情况，最大匹配仅有一种
### 如何规约为最大流问题
V的所有顶点之前给一个顶点作为源，连接到V的所有顶点，在U的所有顶点之后加一个顶点作为汇，U中所有订点都连接到上面；每条边限制流量为1.
## 匹配
匹配的概念不仅限于二分图，严格的匹配指的是图中边的子集，其中任何两条边都不共一个顶点
### Hall婚姻定理
如果二分图G={V,U,E},当且仅当对于每个子集S属于V,s的领接顶点集R(s)的顶点数目大于等于S的时候，才会有匹配存在；但是hall定理存在的问题是，它需要求V中的所有子集，这一点效率是指数的，所以完全放弃改思路求其最大匹配，是否能使V中每个点都匹配上
## 稳定婚姻问题（有优先级的二分图匹配）
相对比较简单，注意性别倾向性
自由男生按女生优先级求婚，女生自由直接接受，不自由跟当前配偶比较，更好则换掉当前配偶，男生完成匹配后到下一个男生，如此循环，直到没有自由男生
# 总结
这一章的内容是图，bfs，回溯（记录路径），迭代改型思想的综合
