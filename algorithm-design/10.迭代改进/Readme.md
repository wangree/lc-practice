本章主要针对图算法
# 单纯形法
## 极点定理 
可行区域非空的任意线性规划问题有最优解，而且，最优解总是能够在可行区域的一个极点上找到  
## 一般步骤
1.初始化：首先是将问题转换为标准形式，所有变量都必须是非负的，必须是一个最大化问题，不等式约束利用松弛因子转换为等式，假设我们得到的是m个n元方程组成的方程组；将其中n-m个变量置为0，化为m个m元方程组，在对应矩阵满秩时就得到了一个基本解，设为0的那些就认为是非基本的；如果一个基本解的所有坐标值都为非负则该基本解被称为基本可行解;表现在单纯形表上就是建立一个初始表，它的最右列的单元格都是非负的，接下来的m列组成了一个m x m的单位矩阵（目标行的单元格不必满足这一条件，目标行是目标函数的相反数对应的系数向量，非零值均为负数，将它们划为0代表目标行最右侧）（这种做法解释一下就是提取出线性方程组中共有的设为0，其他设为1，因为松弛因子的特殊性，所以它是每个方程独有的，故而形成了一个单位阵，保证了松弛因子根据方程解出的值非负）。这m列确定了初始的基本可行解的基本变量，而表格中的行用基本变量来标识  
2.最优测试：如果目标行中所有单元格都是非负的（除了最右列），就可以停止了：该表格代表的是一个最优解，它的基本变量的值在最右列中（因为对于基本变量是单位阵，所以尽管和行对齐但是它可以代表基本变量的值），而剩下的非基本变量的值是0。(为什么目标列最右是目标函数值，可能因为每次用主元行消去输入变量的系数时顺便会把系数*输入变量累加到目标列最右元素）  
3.确定输入变量：从目标行的前n个单元格选择一个非零单元格（一般选择绝对值最大的那个负单元格，使得新的基本变量对目标函数的提升是最大的），该单元格所在的列确定了输入变量和主元列，输入变量是新的基本变量  
4.确定分离变量：对于主元列上的每个正单元格，将其所在行最右单元格除以主元列的单元格，求得一个$\theta$比率，找出$\theta$比率最小的行（$\theta$的意思就是将某个基本变量变为0的减少量与新新基本变量的提升系数之比，这个值越小代表对目标函数的提升越大），（如果主元列没有正单元格则该问题无界），该行确定了分离变量和主元行，主元行在生成下一张表时是用来消元的，分离变量在生成新表时会变成非基本变量  
5.建立下一张表格：将主元行中所有单元格除以主元（主元行和主元列相交的元素）得到新主元行（使输入变量的系数为1）并用它消去主元列对应的其他行系数，使得除了主元行，输入变量的系数都为0；然后把主元行前的标识用主元列的变量名代替，代表新的基本变量诞生  

单纯形法的最差效率是指数级的，若m和n是约束等式和变量的数量，算法的迭代次数在m和3m之间，迭代次数与mn成正比，建议后面可不再看

## 单纯形法与背包问题
背包问题的连续版本可以通过
单纯形法，因为它是一般线性规划问题的特例（参见第 6.6 节中的示例 2）。 然而，这并不是解决这个问题的好方法，因为它可以通过基于贪婪方法的更简单的算法来更有效地解决。 你可能想自己设计一个这样的算法，然后再在书中查找。
背包问题的 0-1 版本无法通过单纯形方法解决，因为问题的变量上施加了完整性 (0-1) 约束 
## 线性规划的其他问题
除非k=1,否则线性规划问题不可能具有k>=1个确定个数的解；我们可以通过反证法证明：线性规划问题的最优解集是凸的。 任何非空凸集可以包含单个点或无限多个点 
## 线性规划的对偶问题
![](https://github.com/wangree/lc-practice/blob/master/algorithm-design/10.%E8%BF%AD%E4%BB%A3%E6%94%B9%E8%BF%9B/Screenshot_20220103_120548_cn.wps.moffice_eng.jpg)
两者有相同的目标函数最优值
# 最大流量问题
该方法是贪婪和bfs及迭代改进思想的综合，大致思路是用源点初始化队列，pop出front来作为队首，找i可以未标记的前向边点（剩余流量大于0）和后向边点（流量大于0），按次序加入队列，然后pop队首，如此循环，直到汇被标记，汇被标记后从队尾进行流量增益，对于有前向点标记的减去流量,对于有后向点标记的加上流量，每个点的当前流量会被记录下来，增益结束后清空源点外的标记，并初始化队列为只有源和其初始标记，接着再进行队列的bfs循环，直到队列内pop至空。
## 最大流-最小割定理或者叫最大流最小切分定理
切分或者割指的是将所有顶点分为两个不相交的集合，而一条横切边则是连接分别存在于两个集合中的两个顶点的一条边
## 算法效率
该算法的效率是O(EV^2/2),一条增广路径至少有一个关键边，所以我们可以用关键边数量来估计增广路径的个数，由于每条边能够成为关键边至少会让这个边某点到s的距离增加2，也就是路径长度增加2,而一条增广路径到最后最多长度是V,所以一条关键边最多会成为V/2次关键边(具体来说，这条边的某个点u,最极端情况下在一开始成为关键边时距离s为0,经过多次增广后由于路径长度最多为v-1,而它和s的距离最多为v-2,也就是说它距离终点t至少有1,所以它做关键边最多为V/2-1，所以经过它的增广路径最多有EV/2条，所以最终是EV^2/2,具体见https://www.cnblogs.com/uid001/p/10465580.html
# 二分图的最大匹配
## 一些匹配的概念
* 增益路径
* 不饱和点（自由顶点）
* 偶图/交替路径
* 匹配/完美匹配/最大匹配
## 贝尔热定理的证明
* 该定理是当且仅当匹配M不存在增益路径时，M是最大匹配
* 可以通过证明其逆否命题：M不是最大匹配，M存在增益路径，反证法M非最大匹配,假设不存在增益路径。如果M非最大匹配，设M<sup>+</sup>为最大匹配，则M与M<sup>+</sup>的对称差要么是偶图（M中的边和 M<sup>+</sup> 中的边各占一半），要么是交替路径（奇数），由于 M<sup>+</sup> ，则一定有交替路径出现才行，并且起点路径和终点路径必然都在 M<sup>+</sup> 中(和原图G没有关系），因而我们发现了一条增益路径，假设不成立
## 二分图寻找最大匹配的算法
* 根据以上定理，最关键的还是如何寻找增益路径
* 一次匹配开始，从自由顶点出发的bfs将能够连接到的点匹配了一遍后，已经找遍了所有能够进行增益的路径，因为bfs不会有所遗漏，所以认为找不到增益路径了，所以就是最大匹配
### bfs寻找最大匹配算法(伪代码）
```cpp
Q={自由顶点}
M;//匹配
while(Q!=empty()){
   v=Q.front();
   Q.pop();
   if(v属于V){
       for(vv:v的邻接点）{
       if(vv已经匹配 && vv未标记）{
          vv标记为v;
          Q.push(vv);
          }
       else if(vv是自由顶点）//进行增益{
          M.push_back((v,vv));
          while(v被标记）{
              v_pre=v的标记点；
              M.erase((v_pre，v));
              v=v_pre标记的点；
              M.push_back((v,v_pre));
          }
          抹去所有顶点的标记；
          用目前的所有自由顶点初始化Q;
       }
       }
    }
    else{
        v_next=v的匹配点;
        v_next标记为v;
        Q.push(v_next);
        }
}
return M;
```
## 稳定婚姻问题（有优先级的二分图匹配）
相对比较简单，注意性别倾向性
自由男生按女生优先级求婚，女生自由直接接受，不自由跟当前配偶比较，更好则换掉当前配偶，男生完成匹配后到下一个男生，如此循环，直到没有自由男生
# 总结
这一章的内容是图，bfs，回溯（记录路径），迭代改型思想的综合
