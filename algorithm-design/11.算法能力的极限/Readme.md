# 如何求下界
下界是求解某个问题的算法理论上能达到的最高效率
## 平凡下界
问题输入的规模结合输出问题的规模，可以得到问题的平凡下界，就是说问题的效率不会高于该下界。典型的例子是求排列的算法，该算法输入规模为1，但是输出为n!,平凡下界为n!.但这样很可能不是紧密的，紧密的意思就是已经一个和该下界效率相同的算法。然而这个下界计算的障碍在于有时候无法准确估计一个算法输入的规模，比如在有序数组中查找数字不需要处理所有数字
## 信息论下界
根据信息论方法得到算法必须处理的信息量，后面结合决策树来看。比如在1和n直接通过一些非此即彼的问题来猜一个数字，要处理的信息量为log_2 n
## 对手论证的下界
对手策略：在每次基本操作(适应所有算法）时动态构造最差的输入，但整个过程中要保持一致不能出现前后矛盾，最后理论最少的操作数就是敌手下界。这个思路成立的原理就是一个能够解决问题的算法，对最差的输入肯定都能够cover,我们可以根据最差输入的必要操作(也就是最少的操作）来估计算法下界。  
书中举的例子是我们合并两个有序数组，并且给一个让算法运行最慢的条件I<j时，a_i<b_j，假设a,b中没有相等的元素，那么最终得到的合并结果一定是b_1<a_1<b_2<...<a_n,每一个<都代表一个必须的比较，因为如果没有比较，假如没有a_1和b_2的比较，我们将无法区分b_1<b_2<a_1<...<a_n和正确结果的区别

参考:https://blog.csdn.net/qq_44954803/article/details/89457507
证明算法复杂度下界---对手论证(adversary argument）
* 什么是对手论证？
将算法设计者与算法分析者看作对手，同时扮演两个角色进行算法分析。  
算法设计者：尽量多的创造更多信息  
算法分析者：尽量少的给予信息，即增多无用操作，拥有着随时合理改变取值的能力，即通过对手策略动态构造输入，最差输入能更加接近必要操作的数目  
只有这二者做到极致，对手论证才能成立。  
注：从分析者的角度可以忽视很多细节，凑出题目所要求的大小即可    
* 最大值最小值问题   
问题描述：  
给定数列，设计算法输出最大值和最小值，并给出该问题的算法复杂度下界   
默认关键操作为比较  
每个元素可能有四种状态：W,L,N,W/L，代表曾经在某次比较中胜出，败北，没有经历过比较，胜出和败北都经历过，  
由于W/L的元素一定不是max/min，所以最终一定是处于两个元素W，L，其余元素W/L的情形  
需要获得的信息总量：  
n个元素都要从N到W or L n个信息  
n-2个元素要从W到W/L n-2个信息  
共计2n-2个  
于是我们的对手策略设计如下：  
比较N：N，结果必然是W,L（L，W与之等价），设计者获得两个信息，分析者无法改变这一事实  
比较W,L,分析者让其继续为w,L即可让他徒劳无获  
比较W,W,结果必然是W,W/L分析者无法改变这一事实  
比较W,N,分析者让他是W，L,即可让他只获得一个信息  
需要获得的总信息量最少是2n − 2   
而我们上面的分析可知，最少需n/2+n-2 次比较才能获得那么多的信息量(因为我们要让信息获取最多，则N:N比较一共最多出现n/2次,对应于我们可以获得2*n/2个信息，然后其余信息每次比较只能获得一个，即n-2次),于是下界为O(3/2n-2)
* “第二大”问题  
问题描述：  
问题：选出一个数列的第二大元素，给出该问题的算法复杂度下界
思路：  
想选出第二大，必先选出第一大（n-1），第二大只有可能是直接输给第一大的那些人里面的人
解：
想选出第二大，必先选出第一大，（n-1），我们给每个点初始化一个权重w(i)=1，并且每当算法进行比较x:y时，我们可以通过把权值给更大的值，小的变为0，并且动态调整操作如下：w(x)>=w(y),则使x>y,w(x)=w(x)+w(y),w(y)=0，通过更新权重来记录比较的次数；基于上述反应，可以看到每一次的更新都不会使得权重翻倍，因此对于最大元素w(x)=n,因为所有1的和是守恒的，而最大的数字的权重最终会是总数n,其他数字是0,其至少更新了log(n)次，即至少有log(n)个直接输给最大元素的家伙，从它们之中选出最大：logn-1
综上所述：下界为O(n + logn − 2)
* 中位数问题
问题描述：
选出一个数列的中位数
思路：
要使得算法能够找到中位数，算法必须至少要做n-1个和中位数有关的比较(可以通过类比n个节点的树有n-1条边来理解)，我们定义这种比较为有效比较，我们将掺杂(n−1)/2个无效比较,具体可看
[参考答案](https://www.zhihu.com/question/19700726#:~:text=%E5%AF%B9%E6%89%8B%E8%AE%BA%E8%AF%81%E6%96%B9%E6%B3%95%E6%98%AF%E6%89%BEf%20%28n%29%E7%9A%84%E4%B8%80%E7%A7%8D%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95%E3%80%82%20%E5%AE%83%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%E6%98%AF%E5%AF%B9%E6%AF%8F%E4%B8%80%E4%B8%AAA%EF%BC%8C%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E8%BE%93%E5%85%A5%E7%89%B9%E6%AE%8A%E7%9A%84%E8%BE%93%E5%85%A5I%27%EF%BC%8C%E4%BD%BFT,%28A%2CI%27%29%E5%B0%BD%E9%87%8F%E5%9C%B0%E5%A4%A7%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E6%89%80%E6%9C%89A%E7%9A%84%E9%9B%86%E5%90%88%E4%B8%8A%EF%BC%8C%E6%B1%82T%20%28A%2CI%27%29%E7%9A%84%E5%B0%BD%E9%87%8F%E5%A5%BD%E7%9A%84%E4%B8%8B%E7%95%8C%E4%BD%9C%E4%B8%BAf%20%28n%29%E3%80%82)  
简而言之，动态调整策略为：定义L：所有比中位数大的集合，S：所有比中位数小的集合
每当算法进行比较x:y时，我们给出以下反应：
N,N⇒ L，S
L,N/S,N ⇒ L,S/S,L，且定死：最后一个具有属性N的是中位数，就是说我们要使无效比较最多，每次都动态调整成L,S,像L,L和S,S是可以帮助最终得出中位数的有效比较
那么要将所有N分配到L和S至少需要( n − 1 ) / 2 个无关中位数的操作，即无效操作，即最差输入下总操作数至少要( n − 1 ) / 2+n次操作

* 有序矩阵搜索问题
问题描述.  
一个n*n矩阵，其每行元素从左到右升序排序，每列元素自上而下升序排序，现给一个数k，找到k在矩阵中的位置
证明改问题的算法复杂度下界为O ( 2 n − 1 ) \Omicron(2n-1)O(2n−1).   

思路： 
该矩阵的每一个斜对角线都是一个等价类，之间无任何关系，因此我们的对手策略就很清晰了：.   
将算法逼到最中间的那两条线上（这两条斜对角线元素之和为2n-1），无论如何算法都要比较这两条斜对角线即可，我们将在上面的斜对角线记为l1,另一条记为l2.
假定算法选定的元素为u，目标是k，策略如下：
若u在两条斜对角线之下的某条斜对角线，则u>k。
若u在两条斜对角线之上的某条斜对角线，则u<k。
若u在l1上且还没有比完l2上所有元素，则u<k.
若u在l2上且还没有比完l1上所有元素,则u>k.
经过以上策略，算法一定会到达l1,l2并将其元素尽数比完，问题下界即O(2n−1)，总结一下就是将我们的输入中k在中间的两条斜对角线上时，搜索需要的操作最多？
## 问题化简
如果q问能够化简为p问题，就是说p复杂度更低，那么p的下界也是q的一个下界；q能够化简为p,则p的任意实例可以通过提高复杂度转换为q的实例，也就是说我们可以通过将算法变为一个复杂度更低的算法来证明其下界；例如我们可以通过简化任意矩阵为对称矩阵，来通过对称矩阵乘法来求普通矩阵乘法的一个下界
### 挪盘子问题的问题下界证明
将黑白插空的棋子变为左侧全白右侧全黑，只能移动相邻棋子，需要的挪动次数是多少？  
这里可以观察到，在第i个白棋子左侧有i个黑棋子，从结果角度来看，如果只能移动相邻棋子对于第i个白棋子而言它至少要和它左侧每个黑棋子发生交换，则对于所有白棋子而言，下界为sum_{i=1}^{n} i = n(n+1)/2,而显然设计简单算法可以达到这个下界
### 汉诺塔下界证明
证明汉诺塔下界为M(n)=2^n-1。从汉诺塔的算法过程中就可以通过归纳法得到其下界的证明：显然在n=1的时候，只需要把a柱的碟子挪到c柱即可，下界成立；而在n-1>1时，我们假设也成立，回到挪动过程，对于n个盘子，如果要把最大盘挪到c，则一定要把除它外的n-1个盘子挪到另外一个柱子上，这要花费2^(n-1)-1，然后把最大盘挪到c,然后再把n-1个小盘挪到c，又需要花费M(n-1),则不难得出M(n).
# 决策树
## 信息论下界
用决策用展示一个算法的基本操作的树，树的高度或者平均深度分别对应该问题最坏和平均情况下的信息论下界
比如插入排序或者选择排序的算法运行过程可以有一个执行比较的二叉树；二分查找也可以有一个执行比较的三叉决策树(不够紧密，实际上相等的分叉并没有进行比较）和二叉决策树

# 问题的分类
搜索问题：如果一个问题有解且验证它的解的正确性所需的时间不会超过输入规模的多项式，则称这种问题为搜索问题，这类问题可以快速验证，但是在不知道有没有解，也没有一个现成解的时候去求一个解的很困难的。而有没有解属于是决定性问题，求最优解是最优化问题，这是对于算法问题的基本分类，尽管它们在技术上并不相等，但一般都能够相互规约。从这个角度来讲，NP是所有搜索问题的集合。   
不可判定或者说不可决定，无解的那一类判定问题称作不可判定问题，如[停机问题](https://baike.baidu.com/item/%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98/4131067?fr=aladdin),在这里也稍作证明：
如果有一个算法A可以对任意程序P的输入I进行进行停机判断，即A(P,I)=0代表程序P的输入I会陷入无限循环，A(P,I)=1代表程序P的输入I会及时停机；那么假如程序P的输入比较特殊是自身，则我们可以构造程序Q(P)在A(P,P)为0时停机，在A(P,P)为1时无限循环，则对于Q(Q)我们有A(Q,Q)=0时停机，但这时候根据A的定义我们知道这时候Q对自身应该是会陷入无限循环的，对A(Q,Q)=1也是一样矛盾的。停机问题就是一个典型的不可解问题。
# P、NP和NP完全问题
## p问题
能够在多项式时间内求解的问题，就是p问题。从另外一个角度讲，p是能够在多项式时间内解决的所有搜索问题的集合，所以可以说p描述了目前能够保证在合理的时间范围内解决的所有问题的集合。
## 不确定算法和NP类问题
找不到多项式类型的算法的问题，也无法从数学上系统证明这类算法不存在，书中列举：
* 哈密顿回路问题（欧拉问题却不是这类问题，找到一条能够访问所有顶点的简单路径）
* 旅行商问题
* 背包问题O(nW) w随着输入规模指数增长，可以参考[伪多项式时间算法](https://www.zhihu.com/question/20013122/answer/44460397)
* 划分问题
* 装箱问题
* 图的着色问题
* 整数线性规划问题
* 分解质因数
* 在无向图（边权重相等）中使用bfs查找简单最短路径是线性问题，但是查找最长路径却最差却是指数的（这里存疑，说法不够严格）


NP的全称是nonderterminism problem,意思是当一个算法面对若干个选项时，它有能力猜出正确的选择，就是不确定性的生成一些解然后再去在多项式时间内验证这些解是否成立，即可以用不确定多项式算法求解的问题
[np,p,npc,np-hard的概念和关系](https://www.cnblogs.com/alantu2018/p/8464339.html)讲的比书上更好
也可以参考：https://blog.csdn.net/qq_38228254/article/details/79506479
大体上说，p是多项式时间内可求解，np是多项式时间内可验证，所以p一定属于np,npc是所有np问题可以约化（复杂度提高,更难的问题）的问题，np-hard是无法求解的判定问题和npc问题的并集，np-hard的定义是at least as hard as NP compelete problem；
## npc问题和规约
A能能归约为b,b的解则说明b问题复杂度更高。为了解决问题 A 最多需要解决多项式个问题 B 的实例，且问题归约最多只需多项式时间。在这种情况下，我们称 A 能够在多项式时间内归约 为 B
所有np问题可以在多项式时间内归约为a,则称a为np完全问题
## p,np,npc的关系
![](https://github.com/wangree/lc-practice/blob/master/algorithm-design/11.%E7%AE%97%E6%B3%95%E8%83%BD%E5%8A%9B%E7%9A%84%E6%9E%81%E9%99%90/Screenshot_20220117_093727_com.flyersoft.moonreaderp.jpg)
# 数值算法的挑战
阶段误差（数值算法本身的误差）；舍入误差和有效数字有关；溢出（如超大数相乘），下溢（如减去抵消）；不稳定性；要尽量通过化简等形式避免舍入误差
捎带介绍了牛顿法计算平方根
