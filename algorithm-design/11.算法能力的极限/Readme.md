# 如何求下界
## 平凡下界
问题输入的规模结合输出问题的规模，可以得到问题的平凡下界，就是说问题的效率不会高于该下界。典型的例子是求排列的算法，该算法输入规模为1，但是输出为n!,平凡下界为n!.但这样很可能不是紧密的，紧密的意思就是已经一个和该下界效率相同的算法。然而这个下界计算的障碍在于有时候无法准确估计一个算法输入的规模，比如在有序数组中查找数字不需要处理所有数字
## 信息论下界
根据信息论方法得到算法必须处理的信息量，后面结合决策树来看。比如在1和n直接通过一些非此即彼的问题来猜一个数字，要处理的信息量为log_2 n
## 对手论证的下界
对手策略：在每次基本操作(适应所有算法）时动态构造最差的输入，但整个过程中要保持一致不能出现前后矛盾，最后理论最少的操作数就是敌手下界。书中举的例子是我们合并两个有序数组，并且给一个让算法运行最慢的条件I<j时，a_i<b_j，假设a,b中没有相等的元素，那么最终得到的合并结果一定是b_1<a_1<b_2<...<a_n,每一个<都代表一个必须的比较，因为如果没有比较，假如没有a_1和b_2的比较，我们将无法区分b_1<b_2<a_1<...<a_n和正确结果的区别

参考:https://blog.csdn.net/qq_44954803/article/details/89457507
* 用对手论证计算求最大最小值的效率下界

复杂度下界

登录


LDawn_
关注
算法复杂度下界证明---对手论证(adversary argument)基础篇 原创
2019-04-22 17:56:55
 6点赞

LDawn_ 

码龄3年

关注
证明算法复杂度下界---对手论证(adversary argument）
什么是对手论证？
从同大小问题引入
问题描述：
思路
“第二大”问题
问题描述：
思路：
解：
中位数问题
问题描述：
思路：
有序矩阵搜索问题
问题描述
思路：
O（n）查环问题
问题描述
思路
什么是对手论证？
将算法设计者与算法分析者看作对手，同时扮演两个角色进行算法分析。

算法设计者：尽量多的创造更多信息
算法分析者：尽量少的给予信息，拥有着随时合理改变取值的能力
只有这二者做到极致，对手论证才能成立。

注：从分析者的角度可以忽视很多细节，凑出题目所要求的大小即可

从同大小问题引入
问题描述：
给定数列，设计算法输出最大值和最小值，并给出该问题的算法复杂度下界

思路
默认关键操作为比较
每个元素可能有四种状态：W,L,N,W/L，代表曾经在某次比较中胜出，败北，没有经历过比较，胜出和败北都经历过，
由于W/L的元素一定不是max/min，所以最终一定是处于两个元素W，L，其余元素W/L的情形
需要获得的信息总量：

n个元素都要从N到W or L n个信息
n-2个元素要从W到W/L n-2个信息
共计2n-2个
于是我们的对手策略设计如下：

比较N：N，结果必然是W,L（L，W与之等价），设计者获得两个信息，分析者无法改变这一事实
比较W,L,分析者让其继续为w,L即可让他徒劳无获
比较W,W,结果必然是W,W/L分析者无法改变这一事实
比较W,N,分析者让他是W，L,即可让他只获得一个信息
需要获得的总信息量最少是2 n − 2 2n-22n−2

而我们上面的分析可知，最少需n 2 + n − 2 \frac{n}{2}+n-2 
2
n
​
 +n−2次比较才能获得那么多的信息量(因为我们要让信息获取最多，则N:N比较一共最多出现n/2次对应于我们可以获得2*n/2个信息，然后其余信息每次比较只能获得一个，即n-2次)
于是下界为O ( 3 n 2 − 2 ) \Omicron(\frac{3n}{2}-2)O( 
2
3n
​
 −2)

## 问题化简
如果q问题能够化简为p问题,那么p问题的复杂度与q问题相等
# 决策树
## 信息论下界
用决策用展示一个算法的基本操作的树，树的高度或者平均深度分别对应该问题最坏和平均情况下的信息论下界
比如插入排序或者选择排序的算法运行过程可以有一个执行比较的二叉树；二分查找也可以有一个执行比较的三叉决策树(不够紧密，实际上相等的分叉并没有进行比较）和二叉决策树

# 问题的分类
搜索问题：如果一个问题有解且验证它的解的正确性所需的时间不会超过输入规模的多项式，则称这种问题为搜索问题，这类问题可以快速验证，但是在不知道有没有解，也没有一个现成解的时候去求一个解的很困难的。而有没有解属于是决定性问题，求最优解是最优化问题，这是对于算法问题的基本分类，尽管它们在技术上并不相等，但一般都能够相互规约。从这个角度来讲，NP是所有搜索问题的集合。   
不可判定或者说不可决定，无解的那一类判定问题称作不可判定问题，如[停机问题](https://baike.baidu.com/item/%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98/4131067?fr=aladdin),在这里也稍作证明：
如果有一个算法A可以对任意程序P的输入I进行进行停机判断，即A(P,I)=0代表程序P的输入I会陷入无限循环，A(P,I)=1代表程序P的输入I会及时停机；那么假如程序P的输入比较特殊是自身，则我们可以构造程序Q(P)在A(P,P)为0时停机，在A(P,P)为1时无限循环，则对于Q(Q)我们有A(Q,Q)=0时停机，但这时候根据A的定义我们知道这时候Q对自身应该是会陷入无限循环的，对A(Q,Q)=1也是一样矛盾的。停机问题就是一个典型的不可解问题。
# P、NP和NP完全问题
## p问题
能够在多项式时间内求解的问题，就是p问题。从另外一个角度讲，p是能够在多项式时间内解决的所有搜索问题的集合，所以可以说p描述了目前能够保证在合理的时间范围内解决的所有问题的集合。
## 不确定算法和NP类问题
找不到多项式类型的算法的问题，也无法从数学上系统证明这类算法不存在，书中列举：
* 哈密顿回路问题（欧拉问题却不是这类问题，找到一条能够访问所有顶点的简单路径）
* 旅行商问题
* 背包问题O(nW) w随着输入规模指数增长，可以参考[伪多项式时间算法](https://www.zhihu.com/question/20013122/answer/44460397)
* 划分问题
* 装箱问题
* 图的着色问题
* 整数线性规划问题
* 分解质因数
* 在无向图（边权重相等）中使用bfs查找简单最短路径是线性问题，但是查找最长路径却最差却是指数的（这里存疑，说法不够严格）


NP的全称是nonderterminism problem,意思是当一个算法面对若干个选项时，它有能力猜出正确的选择，就是不确定性的生成一些解然后再去在多项式时间内验证这些解是否成立，即可以用不确定多项式算法求解的问题
[np,p,npc,np-hard的概念和关系](https://www.cnblogs.com/alantu2018/p/8464339.html)讲的比书上更好
也可以参考：https://blog.csdn.net/qq_38228254/article/details/79506479
大体上说，p是多项式时间内可求解，np是多项式时间内可验证，所以p一定属于np,npc是所有np问题可以约化（复杂度提高,更难的问题）的问题，np-hard是无法求解的判定问题和npc问题的并集，np-hard的定义是at least as hard as NP compelete problem；
## npc问题和规约
A能能归约为b,b的解则说明b问题复杂度更高。为了解决问题 A 最多需要解决多项式个问题 B 的实例，且问题归约最多只需多项式时间。在这种情况下，我们称 A 能够在多项式时间内归约 为 B
所有np问题可以在多项式时间内归约为a,则称a为np完全问题
## p,np,npc的关系
![](https://github.com/wangree/lc-practice/blob/master/algorithm-design/11.%E7%AE%97%E6%B3%95%E8%83%BD%E5%8A%9B%E7%9A%84%E6%9E%81%E9%99%90/Screenshot_20220117_093727_com.flyersoft.moonreaderp.jpg)
# 数值算法的挑战
阶段误差（数值算法本身的误差）；舍入误差和有效数字有关；溢出（如超大数相乘），下溢（如减去抵消）；不稳定性；要尽量通过化简等形式避免舍入误差
捎带介绍了牛顿法计算平方根
