# 如何求下界
下界是求解某个问题的算法理论上能达到的最高效率
## 平凡下界
问题输入的规模结合输出问题的规模，可以得到问题的平凡下界，就是说问题的效率不会高于该下界。典型的例子是求排列的算法，该算法输入规模为1，但是输出为n!,平凡下界为n!.但这样很可能不是紧密的，紧密的意思就是已经一个和该下界效率相同的算法。然而这个下界计算的障碍在于有时候无法准确估计一个算法输入的规模，比如在有序数组中查找数字不需要处理所有数字
## 信息论下界
根据信息论方法得到算法必须处理的信息量，后面结合决策树来看。比如在1和n直接通过一些非此即彼的问题来猜一个数字，要处理的信息量为log_2 n
## 对手论证的下界
对手策略：在每次基本操作(适应所有算法）时动态构造最差的输入，但整个过程中要保持一致不能出现前后矛盾，最后理论最少的操作数就是敌手下界。这个思路成立的原理就是一个能够解决问题的算法，对最差的输入肯定都能够cover,我们可以根据最差输入的必要操作(也就是最少的操作）来估计算法下界。  
书中举的例子是我们合并两个有序数组，并且给一个让算法运行最慢的条件I<j时，a_i<b_j，假设a,b中没有相等的元素，那么最终得到的合并结果一定是b_1<a_1<b_2<...<a_n,每一个<都代表一个必须的比较，因为如果没有比较，假如没有a_1和b_2的比较，我们将无法区分b_1<b_2<a_1<...<a_n和正确结果的区别

参考:https://blog.csdn.net/qq_44954803/article/details/89457507
证明算法复杂度下界---对手论证(adversary argument）
* 什么是对手论证？
将算法设计者与算法分析者看作对手，同时扮演两个角色进行算法分析。  
算法设计者：尽量多的创造更多信息  
算法分析者：尽量少的给予信息，即增多无用操作，拥有着随时合理改变取值的能力，即通过对手策略动态构造输入，最差输入能更加接近必要操作的数目  
只有这二者做到极致，对手论证才能成立。  
注：从分析者的角度可以忽视很多细节，凑出题目所要求的大小即可    
* 最大值最小值问题   
问题描述：  
给定数列，设计算法输出最大值和最小值，并给出该问题的算法复杂度下界   
默认关键操作为比较  
每个元素可能有四种状态：W,L,N,W/L，代表曾经在某次比较中胜出，败北，没有经历过比较，胜出和败北都经历过，  
由于W/L的元素一定不是max/min，所以最终一定是处于两个元素W，L，其余元素W/L的情形  
需要获得的信息总量：  
n个元素都要从N到W or L n个信息  
n-2个元素要从W到W/L n-2个信息  
共计2n-2个  
于是我们的对手策略设计如下：  
比较N：N，结果必然是W,L（L，W与之等价），设计者获得两个信息，分析者无法改变这一事实  
比较W,L,分析者让其继续为w,L即可让他徒劳无获  
比较W,W,结果必然是W,W/L分析者无法改变这一事实  
比较W,N,分析者让他是W，L,即可让他只获得一个信息  
需要获得的总信息量最少是2n − 2   
而我们上面的分析可知，最少需n/2+n-2 次比较才能获得那么多的信息量(因为我们要让信息获取最多，则N:N比较一共最多出现n/2次,对应于我们可以获得2*n/2个信息，然后其余信息每次比较只能获得一个，即n-2次),于是下界为O(3/2n-2)
* “第二大”问题  
问题描述：  
问题：选出一个数列的第二大元素，给出该问题的算法复杂度下界
思路：  
想选出第二大，必先选出第一大（n-1），第二大只有可能是直接输给第一大的那些人里面的人
解：
想选出第二大，必先选出第一大，（n-1），我们给每个点初始化一个权重w(i)=1，并且每当算法进行比较x:y时，我们可以通过把权值给更大的值，小的变为0，并且动态调整操作如下：w(x)>=w(y),则使x>y,w(x)=w(x)+w(y),w(y)=0，通过更新权重来记录比较的次数；基于上述反应，可以看到每一次的更新都不会使得权重翻倍，因此对于最大元素w(x)=n,因为所有1的和是守恒的，而最大的数字的权重最终会是总数n,其他数字是0,其至少更新了log(n)次，即至少有log(n)个直接输给最大元素的家伙，从它们之中选出最大：logn-1
综上所述：下界为O(n + logn − 2)
* 中位数问题
问题描述：
选出一个数列的中位数
思路：
要使得算法能够找到中位数，算法必须至少要做n-1个和中位数有关的比较(可以通过类比n个节点的树有n-1条边来理解)，我们定义这种比较为有效比较，我们将掺杂(n−1)/2个无效比较,具体可看
[参考答案](https://www.zhihu.com/question/19700726#:~:text=%E5%AF%B9%E6%89%8B%E8%AE%BA%E8%AF%81%E6%96%B9%E6%B3%95%E6%98%AF%E6%89%BEf%20%28n%29%E7%9A%84%E4%B8%80%E7%A7%8D%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95%E3%80%82%20%E5%AE%83%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%E6%98%AF%E5%AF%B9%E6%AF%8F%E4%B8%80%E4%B8%AAA%EF%BC%8C%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E8%BE%93%E5%85%A5%E7%89%B9%E6%AE%8A%E7%9A%84%E8%BE%93%E5%85%A5I%27%EF%BC%8C%E4%BD%BFT,%28A%2CI%27%29%E5%B0%BD%E9%87%8F%E5%9C%B0%E5%A4%A7%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E6%89%80%E6%9C%89A%E7%9A%84%E9%9B%86%E5%90%88%E4%B8%8A%EF%BC%8C%E6%B1%82T%20%28A%2CI%27%29%E7%9A%84%E5%B0%BD%E9%87%8F%E5%A5%BD%E7%9A%84%E4%B8%8B%E7%95%8C%E4%BD%9C%E4%B8%BAf%20%28n%29%E3%80%82)  
简而言之，动态调整策略为：定义L：所有比中位数大的集合，S：所有比中位数小的集合
每当算法进行比较x:y时，我们给出以下反应：
N,N⇒ L，S
L,N/S,N ⇒ L,S/S,L，且定死：最后一个具有属性N的是中位数，就是说我们要使无效比较最多，每次都动态调整成L,S,像L,L和S,S是可以帮助最终得出中位数的有效比较
那么要将所有N分配到L和S至少需要( n − 1 ) / 2 个无关中位数的操作，即无效操作，即最差输入下总操作数至少要( n − 1 ) / 2+n次操作

* 有序矩阵搜索问题
问题描述.  
一个n*n矩阵，其每行元素从左到右升序排序，每列元素自上而下升序排序，现给一个数k，找到k在矩阵中的位置
证明改问题的算法复杂度下界为O ( 2 n − 1 ) \Omicron(2n-1)O(2n−1).   

思路： 
该矩阵的每一个斜对角线都是一个等价类，之间无任何关系，因此我们的对手策略就很清晰了：.   
将算法逼到最中间的那两条线上（这两条斜对角线元素之和为2n-1，第n-1和第n或者第n和第n+1条），无论如何算法都要比较这两条斜对角线即可，我们将在上面的斜对角线记为l1,另一条记为l2.
假定算法选定的元素为u，目标是k，动态调整k的策略如下：
若u在两条斜对角线之下的某条斜对角线，则u>k。则显然我们会继续向上或者向左找
若u在两条斜对角线之上的某条斜对角线，则u<k，则显然我们会继续向下或者向右找
若u在l1上且还没有比完l2上所有元素，则u<k，则我们会到l2上找k
若u在l2上且还没有比完l1上所有元素,则u>k,则我们会到l1上找k
经过以上策略，算法一定会到达l1,l2并将其元素尽数比完，问题下界即O(2n−1)，总结一下就是将我们的输入中k在中间的两条斜对角线上时，这其实就是step-wise的算法
## 问题化简
如果q问能够化简为p问题，就是说p复杂度更低，那么p的下界也是q的一个下界；q能够化简为p,则p的任意实例可以通过提高复杂度转换为q的实例，也就是说我们可以通过将算法变为一个复杂度更低的算法来证明其下界；例如我们可以通过简化任意矩阵为对称矩阵，来通过对称矩阵乘法来求普通矩阵乘法的一个下界
### 挪盘子问题的问题下界证明
将黑白插空的棋子变为左侧全白右侧全黑，只能移动相邻棋子，需要的挪动次数是多少？  
这里可以观察到，在第i个白棋子左侧有i个黑棋子，从结果角度来看，如果只能移动相邻棋子对于第i个白棋子而言它至少要和它左侧每个黑棋子发生交换，则对于所有白棋子而言，下界为sum_{i=1}^{n} i = n(n+1)/2,而显然设计简单算法可以达到这个下界
### 汉诺塔下界证明
证明汉诺塔下界为M(n)=2^n-1。从汉诺塔的算法过程中就可以通过归纳法得到其下界的证明：显然在n=1的时候，只需要把a柱的碟子挪到c柱即可，下界成立；而在n-1>1时，我们假设也成立，回到挪动过程，对于n个盘子，如果要把最大盘挪到c，则一定要把除它外的n-1个盘子挪到另外一个柱子上，这要花费2^(n-1)-1，然后把最大盘挪到c,然后再把n-1个小盘挪到c，又需要花费M(n-1),则不难得出M(n).
# 决策树
## 信息论下界
决策树是展示一个算法的基本操作的树，算法的每一步操作如比较都可以使树分叉，树的高度或者平均深度分别对应该问题最坏和平均情况下的信息论下界；因而我们可以从最终能够得到的结果数目也就是叶子数目推算出算法操作的下界；  
基于一个标准假设，即排序的所有n!个输出都不是特殊的，我们可以证明，任何基于比较的算法在对一个n元素的列表排序时，它的平均比较次数的下界是log_2_n!  
而对于二分查找，如果使用三路比较，它对应的决策树是一个三叉树，我们知道其结果有2n+1种，n个成功查找和n+1个不成功的查找，因而其信息论下界为log_3 (2n+1),这就是最坏的情况下三路比较二分查找的效率；但这样的结果并非是紧密的，可以通过适当变形将三叉树变为二叉树，得到紧密的下界log_2_(n+1)
### 信息论下界例子
一堆硬币中有一个较轻的硬币，用天平称重，并不是log_2 n为准确下界，因为从信息论角度，如果把硬币分成三堆，一次称重可以得到比两堆更多的信息。  
还有一个例子是如果有n个硬币有一个假币或者没有假币，不知道假币是轻还是重所以可能的结果有2n+1种，而在比较中把硬币分为三堆，每次称重能得到三种不同的结果，因而信息论下界是log_3 (2n+1);在n=12时，方法如下，其典型特点是第二次放的硬币不受第一次影响，第三次也不受第二次和第一次影响，具有对称性  
![](https://github.com/wangree/lc-practice/blob/master/algorithm-design/11.%E7%AE%97%E6%B3%95%E8%83%BD%E5%8A%9B%E7%9A%84%E6%9E%81%E9%99%90/%E6%97%A0%E6%A0%87%E9%A2%982.png)
### 信息论下界的启发
比如拼板游戏，有n个碎片，一个或多个碎片拼在一起的称为零件，两个零件拼在一起成为一次移动，问如何使得移动次数最少；显然可以和信息论下界方法类比，每个碎片都是一个叶子节点，则树中有n-1个内部节点，所以需要移动n-1次
# 问题的分类
搜索问题：如果一个问题有解且验证它的解的正确性所需的时间不会超过输入规模的多项式，则称这种问题为搜索问题，这类问题可以快速验证，但是在不知道有没有解，也没有一个现成解的时候去求一个解的很困难的。而有没有解属于是决定性问题，求最优解是最优化问题，这是对于算法问题的基本分类，尽管它们在技术上并不相等，但一般都能够相互规约。从这个角度来讲，NP是所有搜索问题的集合。   
不可判定或者说不可决定，无解的那一类判定问题称作不可判定问题，如[停机问题](https://baike.baidu.com/item/%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98/4131067?fr=aladdin),在这里也稍作证明：
如果有一个算法A可以对任意程序P的输入I进行进行停机判断，即A(P,I)=0代表程序P的输入I会陷入无限循环，A(P,I)=1代表程序P的输入I会及时停机；那么假如程序P的输入比较特殊是自身，则我们可以构造程序Q(P)在A(P,P)为0时停机，在A(P,P)为1时无限循环，则对于Q(Q)我们有A(Q,Q)=0时停机，但这时候根据A的定义我们知道这时候Q对自身应该是会陷入无限循环的，对A(Q,Q)=1也是一样矛盾的。停机问题就是一个典型的不可解问题

# P、NP和NP完全问题
## p问题
能够在多项式时间内求解的问题，就是p问题。从另外一个角度讲，p是能够在多项式时间内解决的所有搜索问题的集合，所以可以说p描述了目前能够保证在合理的时间范围内解决的所有问题的集合。正式的p问题定义里还要求p是一个判定问题，但其实任何类型的问题都可以修改为判定问题，这个不是关键
## 不确定算法和NP类问题
找不到多项式类型的算法的问题，也无法从数学上系统证明这类算法不存在，书中列举：
* 哈密顿回路问题（找到一条能够访问所有顶点的简单路径，但欧拉问题却不是这类问题）
* 旅行商问题（完全图的正权重哈密顿回路问题）
* 正整数背包问题（各物品重量，价值以及包的承重量都是正整数,w随着输入规模指数增长，可以参考[伪多项式时间算法](https://www.zhihu.com/question/20013122/answer/44460397))
* 划分问题(给定n个整数，把他们划分为两个子集，其和相等）
* 装箱问题（给定n个物品大小均不超过1，把它们装进数量最少的大小为1的箱子中）
* 图的着色问题（相邻顶点颜色不同需要的最少的颜色数量）
* 整数线性规划问题
* 分解质因数
* 在无向图（边权重相等）中使用bfs查找简单最短路径是线性问题，但是查找最长路径却最差却是指数的（这里存疑，说法不够严格）
* 从n个序列中各选择一个字母使得最终的字母不重复(大小写也算重复)

NP的全称是nonderterminism problem,意思是当一个算法面对若干个选项时，它有能力猜出正确的选择，就是不确定性的生成一些解然后再去在多项式时间内验证这些解是否成立，即可以用不确定多项式算法求解的问题
[np,p,npc,np-hard的概念和关系](https://www.cnblogs.com/alantu2018/p/8464339.html)讲的比书上更好
也可以参考：https://blog.csdn.net/qq_38228254/article/details/79506479
大体上说，p是多项式时间内可求解，np是多项式时间内可验证，所以p一定属于np,npc是所有np问题可以在多项式时间内约化（复杂度提高,更难的问题）的问题，以上列表中问题就属于npc问题，一般认为它是比p复杂度更高的，np-hard是无法求解的判定问题和npc问题的并集，起初是从组合的问题的优化问题来的，np-hard的定义是at least as hard as NP compelete problem；
## npc问题和规约
A能能归约为b,b的解则说明b问题复杂度更高。为了解决问题 A 最多需要解决多项式个问题 B 的实例，且问题归约最多只需多项式时间。在这种情况下，我们称 A 能够在多项式时间内归约 为 B。比较典型的例子是哈密顿回路可以化简为旅行商问题的判定版本(而不是旅行商问题本身，判定版本是要求了长度的，但判定性问题是原问题的基础;一般判定问题和原问题并不等价，比如背包问题，原问题是不大于给定重量情况下价值最大的物品组合，而判定问题是是否存在组合重量不大于给定重量，价值不小于V)，即我们可以把哈密顿回路中一个给定实例的图G映射为旅行商问题实例的一个完全加权图G',方法是把G中的每条边权重设为1，不邻接的顶点加上权重设为2的边，求长度不超过m的哈密顿回路。
所有np问题可以在多项式时间内归约为a,则称a为np完全问题；既不属于p，也不属于npc的np问题也是存在的;如果一个npc问题可以规约为另一个问题，则这个问题也是一个npc问题
## p,np,npc的关系
![](https://github.com/wangree/lc-practice/blob/master/algorithm-design/11.%E7%AE%97%E6%B3%95%E8%83%BD%E5%8A%9B%E7%9A%84%E6%9E%81%E9%99%90/Screenshot_20220117_093727_com.flyersoft.moonreaderp.jpg)
### 偶图
偶图是一个图可以将其中点分为两组不相交的子集，它所有的边都是连接两个子集的点。偶图的充要条件是没有奇数长度的环
### 检测是二色图
使用DFS/BFS，分别没有回边／交叉边(通过这条边就是说访问到一个点已经遍历过，并且这个点不是前趋点),则可以用二色填充；如果有则需要所有交叉边或者回边连接的不是相同奇偶性level的点
### 检查一个数是否是合数
用2到n/2分别除n来检查是否是合数，看起来是O(n)实际上应该用n的二进制位数作为衡量标准(可能是因为除法运算实际上通过移位进行的)，因而它是个指数效率的算法
### 多项式时间内将划分问题转换为背包问题
![](https://github.com/wangree/lc-practice/blob/master/algorithm-design/11.%E7%AE%97%E6%B3%95%E8%83%BD%E5%8A%9B%E7%9A%84%E6%9E%81%E9%99%90/%E6%97%A0%E6%A0%87%E9%A2%98.png)
### 图论中的团，顶点覆盖和独立集
对于任何图 G 和子集其子集V'，以下语句是等价的：
1. V' 是 G 的顶点覆盖（顶点覆盖的定义是子集V'包含所有边中的点中的至少一个）
2. V − v' 是 G 的独立集（独立集中的点不邻接）
3. V − V' 是 G 的补集的一个团 （一个规模为k的团是包含k个订单的完全子图）
### p,NPC,np的可能关系
![](https://github.com/wangree/lc-practice/blob/master/algorithm-design/11.%E7%AE%97%E6%B3%95%E8%83%BD%E5%8A%9B%E7%9A%84%E6%9E%81%E9%99%90/Screenshot_20220125_091707_com.flyersoft.moonreaderp.png）
![](https://github.com/wangree/lc-practice/blob/master/algorithm-design/11.%E7%AE%97%E6%B3%95%E8%83%BD%E5%8A%9B%E7%9A%84%E6%9E%81%E9%99%90/Screenshot_20220125_091721_com.flyersoft.moonreaderp.png)
# 数值算法的挑战
阶段误差（数值算法本身的误差）；舍入误差和有效数字有关；溢出（如超大数相乘），下溢（如减去抵消）；不稳定性；要尽量通过化简等形式避免舍入误差
捎带介绍了牛顿法计算平方根
