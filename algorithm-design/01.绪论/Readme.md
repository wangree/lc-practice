## 习题1.1
11.扩展的欧几里得算法与丢番图方程的求解：
https://blog.csdn.net/marukoheart/article/details/78090296
### 扩展的欧几里德算法
原理阐述：
如果有ma+nb=gcd(a,b),由于gcd(a,b)=gcd(b,a%b)
则也有m1*a+n1*(a%b)=ma+nb
化简得到m=n1,n=m1-a/b*n1
所以就能够得到递推公式
```cpp
int gcd(int a,int b,int* x,int* y){
    if(b==0) {
        *x = 1;
        *y = 0;
        return  a;
    }
    int prevx =0;
    int prevy =0;
    int res = gcd(b,a%b,&prevx,&prevy);
    *x=prevy;
    *y=prevx-a/b*prevy;
    return res;    
}
```
### 丢番图方程
丢番图方程只需要将扩展的欧几里德得到的两个系数再乘以c/gcd(a,b)即可
## 习题1.3
4. 七桥问题
欧拉回路：在回到起点之前，某个路径能够访问图上所有边并且只访问一次
欧拉路径：某个路径能够访问图上所有顶点并且只访问一次不需要回到起点
6. 环游世界问题
哈密顿回路：在回到起点之前，某个路径能够访问图上所有顶点并且只访问一次
## 习题1.4
### 指出如何用下列数据结构实现优先对列
1.无序数组：可把new item放在数组较大成员之后，把所有比它大的成员向后移动一格，类似与插入排序的操作；出队列时，删除最后一个元素，再resize即可；答案给的实现方法是每次把新元素放在最后一个元素之后，每次出队时需要查找最大成员，交换最后一个成员和最大成员  
2. 有序数组：插入排序  
3. 二叉查找树: 按照二叉树正常的插入顺序插入元素，即一路递归寻找空位，二叉树的位置对一个元素来说是确定的，直到寻找到空位即可；删除时，最右如果是父节点，则将左子节点作为其父的右子结点
### 实现一个相对较小，长度为n的字典
由于相对较小，所以可能使用空间占用相对大的方法，而且不需要删除增加Key的话，线性数组是最好的，如array,大小固定为n,其值可以是键值或者1/0这种
### 实现一个计算算术表达式的计算器
采用双stack和逆波兰式，用栈主要想要对最近碰到的运算符进行处理，首先需要将普通表达式转换为逆波兰式，从左往右依次取字符串，如果是数字则放进栈s2,如果是操作符，优先级大于s1栈顶元素（包括左括号，左括号优先级也是很低的），则放进s1(s1最早是最低优先级运算符#），反之，将开始弹出运算符直到运算符优先级低于其优先级时停止弹出，如果碰到左括号则直接送到s1栈顶，如果遇到右括号则开始弹出s1的运算符依次送到s2,直到弹出左括号，结束时把s1中的运算符全部出栈，逆波兰式自己是比较好求值的
