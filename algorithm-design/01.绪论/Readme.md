## 习题1.1
11.扩展的欧几里得算法与丢番图方程的求解：
https://blog.csdn.net/marukoheart/article/details/78090296
### 扩展的欧几里德算法
原理阐述：
如果有ma+nb=gcd(a,b),由于gcd(a,b)=gcd(b,a%b)
则也有m1*a+n1*(a%b)=ma+nb
化简得到m=n1,n=m1-a/b*n1
所以就能够得到递推公式
```cpp
int gcd(int a,int b,int* x,int* y){
    if(b==0) {
        *x = 1;
        *y = 0;
        return  a;
    }
    int prevx =0;
    int prevy =0;
    int res = gcd(b,a%b,&prevx,&prevy);
    *x=prevy;
    *y=prevx-a/b*prevy;
    return res;    
}
```
### 丢番图方程
丢番图方程只需要将扩展的欧几里德得到的两个系数再乘以c/gcd(a,b)即可
## 习题1.2
1.狼羊白菜问题
羊是关键，是食物链的中间，先运输羊，再运输狼，然后回程立刻把羊带回，再运输白菜，最后运输羊  
2.17分钟4人过桥：甲1分钟，乙2分钟，丙5分钟，丁10分钟，两人一起走等于速度最慢的那个，必须携带手电筒，而且手电筒不可扔来扔去  
关键是丙丁的时间要合并，还要有人能回去带手电筒，因而要甲乙先过去（2），然后乙回程（2），丙丁过去（10），甲回程（1），甲乙过去（2）第一次回程的是甲也是一样的
## 习题1.3
4. 七桥问题
欧拉回路：在回到起点之前，某个路径能够访问图上所有边并且只访问一次
欧拉路径：某个路径能够访问图上所有顶点并且只访问一次不需要回到起点
6. 环游世界问题
哈密顿回路：在回到起点之前，某个路径能够访问图上所有顶点并且只访问一次
## 习题1.4
### 指出如何用下列数据结构实现优先对列
1.无序数组：可把new item放在数组较大成员之后，把所有比它大的成员向后移动一格，类似与插入排序的操作；出队列时，删除最后一个元素，再resize即可；答案给的实现方法是每次把新元素放在最后一个元素之后，每次出队时需要查找最大成员，交换最后一个成员和最大成员  
2. 有序数组：插入排序  
3. 二叉查找树: 按照二叉树正常的插入顺序插入元素，即一路递归寻找空位，二叉树的位置对一个元素来说是确定的，直到寻找到空位即可；删除时，最右如果是父节点，则将左子节点作为其父的右子结点
### 实现一个相对较小，长度为n的字典
由于相对较小，所以可能使用空间占用相对大的方法，而且不需要删除增加Key的话，线性数组是最好的，如array,大小固定为n,其值可以是键值或者1/0这种
### 实现一个计算算术表达式的计算器
采用双stack和逆波兰式，用栈主要想要对优先级高的运算符进行处理，因为高优先级的总保持在栈顶，另外的原理就是两个运算符优先级如果从左到右是下降的，需要在遇到第二个运算符之前，把前面的结果弹出进行运算，而括号代表的区域是一定在遇到右括号时要弹出进行运算
#### 标准流程
(1)首先，需要分配2个栈，栈s1用于临时存储运算符（含一个结束符号），此运算符在栈内遵循越往栈顶优先级越高的原则；栈s2用于输入逆波兰式，为方便起见，栈s1需先放入一个优先级最低的运算符，在这里假定为'#'；
(2)从中缀式的左端开始逐个读取字符x，逐序进行如下步骤：
1.若x是操作数，则分析出完整的运算数（在这里为方便，用字母代替数字），将x直接压入栈s2；
2.若x是运算符，则分情况讨论：
若x是'('，则直接压入栈s1；
若x是')'，则将距离栈s1栈顶的最近的'('之间的运算符，逐个出栈，依次压入栈s2，此时抛弃'('；
若x是除'('和')'外的运算符，则再分如下情况讨论：
若当前栈s1的栈顶元素为'('，则将x直接压入栈s1；
若当前栈s1的栈顶元素不为'('，则将x与栈s1的栈顶元素比较，若x的优先级大于栈s1栈顶运算符优先级，则将x直接压入栈s1。否则，将栈s1的栈顶运算符弹出，压入栈s2中，直到栈s1的栈顶运算符优先级别低于（不包括等于）x的优先级，或栈s2的栈顶运算符为'('，此时再则将x压入栈s1;
(3)在进行完(2)后，检查栈s1是否为空，若不为空，则将栈中元素依次弹出并压入栈s2中（不包括'#'）；　　　　　　 
(4)完成上述步骤后，栈s2便为逆波兰式输出结果。但是栈s2应做一下逆序处理，因为此时表达式的首字符位于栈底；
