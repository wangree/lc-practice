## 3.1选择排序与冒泡排序
### 习题3.1
#### 二进制位数所描述的效率：
线性算法 基本操作数为N n≈2^b 那么如果用b来描述 则算法每增加一位二进制 则需要的时间是指数级别的
也就是这个跨步是比较大的 比N一步一步的跨要大很多
#### 对于a^n mod m如何更快的进行处理？
可以使用递归的思想 拆成 ((a^n-1 mod m)*(a mod m))mod m
#### 计算二项式的值的优化
笨办法是在计算每一项时进行单独的计算 优化的办法是算出一项后在下一项乘以底数

## 3.2顺序查找与蛮力字符串匹配
### 习题3.2
### 两个仪器 测试使其坏的最高楼层 一个坏了以后可以用另一个 最佳方法是：
√n查找法 以√n为步长进行测试 具体到某步中 再以1为单位进行测试 效率不会低于2√n 无法使用二分 因为只有两个仪器 二分只能查找两次
### 为什么从右向左字符串匹配更好
Comparing pairs of the pattern and text characters righ-to-left can allow
farther pattern shifts after a mismatch
### 蛮力算法查找以a开头 以b结尾的子串线性改进版
存储a的个数A 和 要求的子串数目sub,初始值均为0,从左到右碰到一个a则为增加a的数目，碰到一个b，则sub加当前A，最后返回sub

## 3.3最近对和凸包问题的蛮力算法
### 最近对问题
典型的蛮力法解决的问题，蛮力法也有技巧进行优化，比如不要重复计数等等
更进一步的优化是 按照X Y的顺序分别排序 计算相邻点的距离 注意是两次排序 
### 凸包问题
### 奇数派问题
每个人手里有一块蛋糕 会扔给他最近的人 证明如果是奇数个人 则一定会有人没有被扔到
#### 解决的思路是最近对和数学归纳法，考虑3个人的情况，最近对会互相仍蛋糕，那么第3个人不会被扔到
考虑n个人的情况 最近对互相扔 如果没有其他人扔蛋糕给最近对 则回归到n-2的情况，按照归纳法的假设，这n-2中会有人没有被扔到；如果有人扔给最近对 剩下的n-2个人的蛋糕显然已经不能满足扔给他们中每个人蛋糕 因为有一块已经扔出去了
N^3的算法
## 3.4 穷举查找
## 旅行商问题
## 背包问题
## 分配问题
