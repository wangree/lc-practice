贪婪很可能不是全局最优的，比如过桥问题就不能用贪婪的策略，但有些时候他的部分解可以扩展到全局最优，这个需要数学归纳法，或者在每一步证明贪婪算法不比其他算法的选择差，或者基于算法的最终结果而不是过程证明它结果已经最优
prime和kruskal完整实现参考https://blog.csdn.net/wr132/article/details/43373991 （里面的邻接链表用了循环数组代替链表实现）
# Prim算法
生成最小生成树的算法;最小生成树是一个图上的边权重总和最小的树（包含所有的点）,这里我们只考虑连通图并且认为每条边的权重都不同，保证最小生成树的唯一性
## 树的基本性质
1.用一条边连接树的任意两个顶点会产生一个新的环
2.从树中删去一条边会得到两棵独立的树
## 切分定理
图的一种切分是将图的所有顶点分为两个非空且不重叠的集合。横切边是一条连接两个属于不同集合的顶点的边；在一幅加权图中，给定任意的切分，它的横切边中权重最小的必然属于图的最小生成树。
### 证明
今e为最小的横切边，T为最小生成树，如果T中不包含e，那么我们把e加入T,则必然得到一个环，这个环必然存在另外一个横切边f,而f>e,则我们如果把f换成e,则发现了一个权重更小的树，产生了矛盾
## 最小生成树的贪心算法
初始所有边都是灰色，对于任意的切分，其横切边都是灰色时，将最小的变为黑色，直到找到了|V|-1条黑色边
### prim算法
Prim算法是上述贪心算法的一种具体实现。从上述算法直接出发，则可以如下述生成最小生成树，找到目前横切边优先队列中最短的e，将其出队，加入最小生成树的边集E_t,然后对于e的两个顶点相连的另一个顶点未被mark的边加入优先队列,并mark这些点，然后再重复进行，直到优先队列为空(对于那些失效的边，会在最后出队但不是做任何操作)；
所谓Marked指的是这个点已经在树中；延时算法会在加入一个e后把两个端点相关的所有右端点不在树中的e加入优先队列，而下个边是优先队列中最小的，但是要满足边的至少有一个不在
```cpp
vector<node> V;
int E[100][100];//该图的输入,该图务必是连通图
v=V.front();//任意一点作为初始顶点
V.pop();
priority_queue< node, vector<node>, less<node> > V_remained(V.begin(),V.end()); //优先队列，其中元素node按照node.weight排列,一开始node.weight= INT_MAX,node.prev= null;剩余元素集合，node的<需要重载，每个node的prev代表它离树最近的点
vector<pair<node,node>> E_tree; //表示prim树的边集，即为最后的结果
for(!V_div.empty())//每次选出一个顶点加入最小生成树，∣V∣-1即可走完，不需要检查V_div是否为空{
    for (auto v_remained:E[v]){//这步操作时间复杂度为O(|V|),如果换成邻接链表，只需要遍历v相关的链表的成员，更新在remain中的标记即可，时间复杂度为O(|E|))
    if(v.isMarked()) continue;//排除已经在树中的点，否则V_div最小边可能不更新  
    if(E[v][v_remained.id]<v_remained.weight){
            //更新权重
            v_remained.weight=E[v][v_remained.id];//V_remained会自动排序
            v_remianed.prev=v;
            V_div.push_back(v_remained);
        }
    }
    v=V_div.front();
    V_div.pop();
    v.mark();
    E_tree.emplace_back(v.prev,v);
}
```
时间效率属于O(|E|log|V|),log|V|是堆内部（优先队列）更新操作
因为优先队列中的顶点数最多为 ∣V∣。算法会进行 V次插入操作,V-1次删除最小元素操作以及E次改变优先级的操作(更新weight),故效率为(E+V-1)*logV为ElogV   
延时算法中最坏的情况为ElogE,因为最多只能插入E条边，删除E次最小元素  
prim算法可以对普通加权无向图做连通性检查，如果运行一遍之后，所有点都加了进来则连通否则是不连通的  
如果所有边权重相等，则使用bfs可以更高效的生成一个最小生成树
### prim算法生成迷宫
https://www.cnblogs.com/WayneShao/p/5890379.html
### 最大相容问题
一组区间（a_1,b_1),...,(a_n, b_n),每个区间表示占用相同资源的人物的开始时间和结束时间，问题是找到最大相容区间数，使得这些区间互不重叠。  
这个问题可以使用贪心策略求解，具体有以下策略：  
1.如果区间重叠则选择最早开始的区间  
可以有反例（0，8），（2，3）， （4，5），（9，10），会选择（0，8），（9，10），这显然是不对的；
2.如果区间有重叠选择最短的那个，（0，4），（3，6），（5，9）会选择（3，6），也不正确；
3.选择完成时间最早的，这个可以有以下证明：
按策略3，得到一组解I,假设如果还有一组解J,比I更优或者区间数目一致，我们首先要证明b_i_r <= b_j_r,a是区间左端点，b是右端点，r是第r个区间，首先由于a是按完成时间最早取的，所以r=0必然满足;使用归纳法我们假设b_i_(r-1) <= b_j_(r-1),显然有b_j_（r-1） <= a_j_r,b_i_(r-1)<=a_j_r,再根据I选择区间的策略i的下一个区间一定比a_j_r的右端点即b_j_r要早，即b_i_r <= b_j_r;  
得到这个结论以后我们发现，如果J的区间数目m>I的区间数目k，则对于区间（a_j_k+1, b_j_k+1)有a_j_k+1>=b_j_k>=b_i_k,那么对I的选法一定会选择这个区间，则I的数目也大于k了产生矛盾，因此k=m,问题得证

### 传播谣言算法
有n个人，每个人都有一个谣言，现要求最短的传播次数下使所有人知道所有谣言，每次每个人要把他知道所有的谣言告诉另一个人，求最少传播次数。  
显然有贪婪算法，1告诉2,2告诉3，…n-1告诉n,n再把所有消息告诉1,2,…，n-1,共需要2(n-1)次传播；这个算法是最优的因为每增加一个人就只增加传播给他的和他给别人的仅两条信息，没有其他信息
### 巴特切砝码问题
求n个砝码{w_1,w_2,...,w_n}的一个集合，使得它可以对天平上重量范围从1到W的任意整数负载进行称重，分别对一下两种条件进行求解：  
a.砝码只能放在天平的一边  
可以证明对于对于n个正整数的集合{w_1,w_2,...,w_n}（按照升序排列），其和如果能够表示从1到总和的所有数字，则要满足w_i<= 2^(i-1);可以使用归纳法进行证明，对于1个元素，显然是满足的；对于i-1个元素，假设每一项都满足w_{k} < 2^{k-1},则前i-1个数组的总和根据最多是$ \sum_k^{k=i-1} w_k < \sum_k^{k=i-1} 2^{k-1} = 2^{i-1}-1 $，而如果第i个元素大于2^{i-1},则从第i个元素开始到n这些数字任意的和不可能小于2^{i-1},则2^{i-1}这个数字将被遗漏，则说明第i个元素要满足<=2^{i-1},证明完毕。  
根据以上结论，我们可以把总和拉到上限，即w_i=2^(i-1),则可以称重任意负载  
b.砝码可以放在两边  
对于集合{w_i=3^{i-1}},可以满足该要求：首先从三进制出发，对于任意的整数都可以表示为$\sum \beta_i*3^i $, $\beta_i$中可能有2，而2可以展开成为3-1，通过多次的合并同次方项，可以得到仅含有1和-1的3的幂函数表达式。  
然后我们来证明对于n个数字的集合，其和和其差的最大不能超过(3^n-1)/2:对于每个砝码都有3种选择，则为3^n-1种安排，而因为有两个天平总有两个互为镜像，故放置方法为(3^n-1)/2，从1连续计数（题目条件 ）的话，能够表示的数字最多是(3^n-1)/2

# Kruskal算法
最小生成树的另一个算法
第二种最小生成树算法的主要思想是按照边的权重顺序（从小到大）处理它们，将边加入最小生成树中（图中的黑色边），
加入的边不会与已经加入的边构成环，直到树中含有V-1条边为止。
这些黑色的边逐渐由一片森林合并为一棵树，也就是图的最小生成树。
这种计算方法被称为 Kruskal 算法 。
证明Kruskal 算法能够计算任意加权连通图的最小生成树。
如果下一条将被加入最小生成树中的边不会和已有的黑色边构成环，那么它就跨越了由所有和树顶点相邻的顶点组成的集合以及它们的补集所构成的一个切分。因为加入的这条边不会形成环、它是目前已知的唯一一条横切边且是按照权重顺序选择的边，所以它必然是权重最小的横切边。因此，该算法能够连续选择权重最小的横切边，和贪心算法一致。
```cpp
V,E;//该图的输入,该图务必是连通图，E是个优先队列，其中元素E[i]按照weight排列
把E中的边按照长度进行排序；
E_tree; //表示prim树的边集E_tree为空
k=0；
auto uF = UF(V); //对每一个点都构造并查集对象
while(!E.empty() && E_tree.size()< V.size()-1)//每次选出一个除初始顶点外的顶点{
    auto e = E.pop();
    v,w为e的两个端点（任意顺序）
    if(!uF.connected(v,w)）{//已经相连代表已经在树中，要跳过
        E_tree.push_back(E[k]);
        uF.union(v, w);
    }
}
return E_tree;
```
该算法的效率为ElogE,该算法表明权重最小的边一定属于某个最小生成树，但要注意并非所有最小生成树，还有有权重重复时，最小生成树还是可能唯一.  
另外，如果还要求得一个非连通图的所有最小生成树(每个连通分量一个)那么需要把所有边都遍历而不是到|V|-1截止
引入并查集进行优化
```cpp
//quick-union算法
V,E;//该图的输入,该图务必是连通图
把E中的边按照长度进行排序；
G_tree={V_tree,E_tree}; //表示prim树的边集E_tree为空,这里的E_tree为孤立的各点，
k=0；
while(valid_edge_num<V.size()-1)//每次选出一个除初始顶点外的顶点{
    k=k+1;
    v=E[k].first;
    u=E[k].second;
    tree_v=find(G_tree,v);//实际的实现应该是find((u,v)),
并不存在G_tree这个东西只有链表，找到了则不做任何事没找到再find(u) find(v)
当然这只是一个思路；也可已只记住点然后标记另一端的点
    tree_u=find(G_tree,u);
    if(tree_v!=tree_u) {
    union(tree_v,tree_u,(v,u),G_tree);
    valid_edge++;
    }//这就省去了查找是否是回路的操作
}
return E_tree;
```
也可以用一个数组set就可以完成并查问题，这个叫做quick-find算法
```cpp
//quick-find算法
V,E;//该图的输入,该图务必是连通图，E是边的vector
E_tree;//输出
把E中的边按照长度进行排序； 
k=0；
set[V.size()];
for(int i=0;i<V.size();i++){
    set[i]=i;
}//set里存的是根的位置，即点的下标
while(valid_edge_num<V.size()-1)//每次选出一个除初始顶点外的顶点{
    k=k+1;
    v=E[k].first;
    u=E[k].second;    
    if(set[v]!=set[u]) {
        //find操作，比较昂贵，需要遍历所有数字
        for(auto vv:V){
           if(set[vv]==set[u]) set[vv]=set[u];
        }
        set[v]=set[u];//合并操作
        E_tree.push_back(E[k]);
        valid_edge++;
    }//这就省去了查找是否形成回路的操作
}
return E_tree;
```
## 并查集
首先所有算法都把每个点都作为自己的根节点，有N个集，然后再进行find,union等操作直到把所有点进行了合适的归类
### quick-find
Quickfind 每个节点都指向根节点，find非常快，但union的时候需要遍历所有节点;每次find只需要访问数组一次，而uinion操作会调用两次find并检查所有N个元素并改变需要改变的元素（每次改变最多需要两次访问两次，读一次，改一次），因而访问数组的次数在N+3和2N+1之间
### quick-find的改进
在union时把小的连通分量向大的上面添加，尽管不能显著提升一次union的效率，但是在一系列操作后，union总效率将是nlogn
### quick-union
每个节点不必指向根节点而是指向另一个同属于一个分量的节点，直到指向根节点,union时只需要将一个节点的根节点指向另一个节点的根节点；该算法中find方法访问次数为节点深度加1，而union需要两次find;quick-union最坏的情况是长链的根节点一直向一个单节点上uinion
### 加权quick-union
它比一般的Quick-union好在小树往大树上添加，小树深度加1大树不动，整体深度不变，反过来大树深度加1整体加1,可以证明该算法生成的深度不超过log_2 K,K为节点总数, 这里需要用一个数组维护每个点的深度;这时候的查找总效率是logn
### 加权quick union的最差情况
![](https://github.com/wangree/lc-practice/blob/master/algorithm-design/09.%E8%B4%AA%E5%A9%AA%E6%8A%80%E6%9C%AF/Screenshot_20211222_142657_com.flyersoft.moonreaderp.png)
### 压缩路权的quick union算法
对find方法进行修改，把find循环经过的每个点最后都链接到根上；但是这对于上面的情况可能无效，所以在每次union后，对深度大于1的点要进行find(但这里也引入了很大的复杂度，所以加权quick union其实已经足够好);quick-find也可以使用路径压缩
### 斯坦纳树
斯坦纳树：平面原来有若干点，现在可以加点使得这个点与原来的点之间形成的树的权重总和最小，是np难问题。  
4个点加入两个点的结果
![](https://github.com/wangree/lc-practice/blob/master/algorithm-design/09.%E8%B4%AA%E5%A9%AA%E6%8A%80%E6%9C%AF/Screenshot_20211227_184814_cn.wps.moffice_eng.png)
# Dijkstra算法
和prim算法有很大的相似性。但它仅适用正权重
单起点最短路径,起点s到所有其他点的最短路径及距离。算法的具体过程是有一个树中点集，还有一个候选的边缘点集一开始是除了是除了起点所有点距离都是无穷，没有前继点，树中点集一开始仅有起点，更新与其相邻的这些点的距离为距起点的距离，并给这些点标注前继点是起点；然后在候选点中选出距离起点最小的p移除出候选点集加入树点集，然后更新其相邻点距离和前继节点(如果候选点到起点距离大于p目前记录的距离和p到候选点距离之和才更新距离和前继点) ,按此循环直到候选点集为空 
用贪婪的策略去寻找，但保证全局最优主要靠更新,首先这个算法有点像bfs/dfs的,但它候选点集一开始就很大，不是每次扩充的，但是它pop的顺序比较特别，按照距离pop,这样可以保证pop点距离最短，因为如果已经遍历的点里有距离更短的点那么不会是该点pop。
那会不会有没被遍历的点有更短的距离？也不会，因为这个点存在则它要么和起点直接相连，那一定会在目前出队列点之前被pop,如果从已遍历的其他点相连也是一样的;最终可以看成它是一种按照距离分层pop的遍历方法，更像bfs. 
另外注意，该算法最终也会有个生成树但不一定是最小生成树
```cpp
V,E,起点s;//输入，如果两点不相连，E为无穷
s.distance=0;
s.prev=null;
Q;//优先队列为空,按distance排序
for(auto vv:V){
    vv.distance= INT_MAX;
    vv.prev=null;
    Q.push(vv);
}
Vt=V;//
for (int i=0;i<V.size()-1;i++){
    u=Q.front();  //u是优先级最小的元素
    Q.pop();
    vt.erase(u);
    for (auto vv:Vt){
        if (E[vv][u]<INT_MAX){
            if (u.distance+E[vv][u]<vv.distance){ //这句就是中转点更新，路径更优的意思，也是该算法的精髓
                vv.distance=u.distance+E[vv][u];
                vv.prev=u;
                update(Q);
        }
    
}
 //类似算法有open close的区分 比如A_* open指的是待更新 close表示已经找到最短距离 已经出队列 这里我们并没有采用类似思路 中途入队
```有向无环图的迪杰斯特拉算法
从起点开始按照拓扑排序的顺序,每个点更新其相邻点距离起点的距离，这个算法是线性的如果使用拓扑排序的话
### 该算法的负权重反例和效率
![](https://github.com/wangree/lc-practice/blob/master/algorithm-design/09.%E8%B4%AA%E5%A9%AA%E6%8A%80%E6%9C%AF/Screenshot_20211228_132904_cn.wps.moffice_eng.jpg)
该算法如果使用矩阵表示图，优先用无序数组来实现优先队列，则效率为O(|V|^2),如果使用邻接矩阵，使用最小堆作为优先队列则效率为ElogV
### 
# 哈夫曼树及其编码
也很简单思想，概率小的放的越深，编码长度越长
char字符按照使用概率排序后，取出前两个，其父节点的概率为两者总和，该树又和其他字符一起排序，然后后面又取出概率最小的两个节点，和前面一样组合出一个新的节点概率为原来两个节点之和，如此往复，最后一颗完整的树，根节点概率为1
