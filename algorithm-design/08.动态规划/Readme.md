# 概述
如果问题是交叠的子问题构成的，我们就可以用动态规划技术来解决它。一般来说，这样的子问题出现在给地你个问题求解的递推关系中，这个递推关系中包含了
相同类型的更小子问题的解。与其对子问题一次又一次的求解，不如用较小的子问题只求解一次而用表把它记录下来。
具体实现方法可以分为经典的从底向上版本和基于记忆功能的从顶向下版本，有时动态规划可以被认为是一种空间换时间的算法，但其实都可以优化
此外，动态规划问题还必须满足最优化法则，即最优化问题任一实例的最优解都是由其子实例的最优解构成的。
典型的问题有背包问题，任意硬币找零，机器人找零问题
## 8.1 三个基本例子
### 币值最大化问题
面值为c1,c2,。。。，cn的硬币，面值不一定两两不同，比如可以是2，10，7，2，请问如何在这n个金币中选择硬币，使得其在原始位置不相邻的情况(问题的关键)下所选硬币的金额最大，核心就是列出递推关系  
F(n)=max(F(n-1),F(n-2)+cn),而F(1)=c1,F(0)=0 所以F的参数也是一个界限
### 找零问题
这个更像全局推荐，在选币时，有m种选择，求数目全局最小，可以有递推关系式
F(n)=min_j*({F(n-d_j)+1})
### 硬币收集问题
硬币收集问题和全局推荐问题比较像 在有确定的层级关系时 即某一层的点的前驱一定来自上一层时(表现为从某方向来可以，其他方向来不行，即无环，典型的树型) 可以用类似的动规
## 习题8.1
### 分治法和动规的区别
交叠的小问题是动规，不重合的是分治
### 动规效率
一般是O(n)的 但是如果是递归算法 就是指数型了
对于币值最大化问题，如果是穷举，对于n枚硬币,有选择与不选两种，总的来说是有2^n种选择
### 切割木棍问题
F(n) = max({n-xi}+pi）i≤n
### 国际象棋的最短路径问题
对于位置(i,j) F(I,j)为到达该点的最短路径个数F(i,j)=F(i-1,j)+F(i,j-1),其实是个更典型的组合问题
##  最小总和问题
该题递推公式是比较好写的 主要是不要直接求某列的结果 而要先求某点的
顶点 0 为起点和其他 n 个顶点对于给定顺序的硬币。起始顶点将连接到每个
其他顶点； 每个代表硬币的顶点在其直接后继之后将具有到每个代表硬币的顶点的出边。 边的权重将是边指向的顶点所代表的硬币的价值。
## 有向无环图的最长路径
和全局推荐类似 有典型的层次结构 可以用动规 币值最大化问题可以化为类似图的形式 长度为币值
典型的动规问题 但可以筛选 不必填所有表格
### 最大子方阵问题
对于矩阵(m,n) 其元素仅可以是0或者1 求其最大
元素为0的最大子方阵 这个题的难点还是在于怎么找到合适的函数 并不是定义F(I,j)为在I,j点的最大子方阵阶数，而应该定义为以(i,j)为右下角元素的子方阵阶数，因而可以得到递推公式为如果 b(I,j)为1则F(I,j)=max(
F(I-1,j),F(I,j-1))+1 如果b(I,j)为0则函数值为0 因而可以依次类推得到结果
### 世界大赛的胜率
N场比赛,A队赢得比赛还有i场，b队还是j场才能赢得比赛，求a队最终赢得比赛的概率P(I,j),a队赢得比赛的概率为p,输掉概率为1-p,没有平局，可以求得递推公式为p(I,j)=p(i-1,j)*p+p(I,j-1)*(1-p) p(0,j)=1 p(I,0)=0 p(0,0)不存在

## 
## 8.2

### 背包问题
背包问题的特殊性在于F(i,j)中的i和j都是界限而不是确数，因而我们只能普适的分为包含i物品和不包含i物品的，不像割绳子长度为n,n是确定的,而且正因为割绳子是确数，所以不能用这种报告i与不包含i去分类;它是界限法而不是过程法
## 习题8.2
### 背包问题的最优解数目
由于明显的层次结构 在每一步动规时都有明确的选择 除非是F(I-1,j-wi)+vi和F(I-1,j)相等，这种情况才会有多解
### 背包问题的非递减性
对于同行，F(I-1,j)≤F(I,j),因为从F的定义上讲左侧是右侧对应物品的子集；同列也是一样
### 每种物品不限数量时的背包问题
这时候没有前I个物品的限制，则F(w)=max{F(w-wj)}+vj w≥wj F(w)=0 for all wj大于w
### 求两个序列中的最长公共子序列
注意公共子序列并不是子串 公共子序列是索引递增的序列 并不一定要连续因而便可以得到递推公式
对于字符串X和Y，如果Xi==Yj，则F(I,j)=F(i-1,j-1)+1 如果Xi！=Yj 则F(I,j)=max(F(i,j-1),F(i-1,j)),
初始条件是F(0,j)或者F(j,0)为0 这个题的思考的方法首先是a串要变b串 最后的改动肯定是X和Y的最后一个值 一般来讲 所以我们会基于P(i,j-1),P(i-1,j),P(i,j)来过渡 P(i,j)指的是X在i位置转变为J位置所需的代价 这时候我们发现会有几种操作和组合 类似于我们的递推式 然后我们发现用P最优应该是用F
### 多边形最优三角划分
这个不能一步一步简单递推 需要从图形上去看 思考多边形的点按逆时针或者顺时针依次是“v0到vn F(V0,vn)=min{F(v0,vk)+weight( 0 ,k,n)+F(vk,vn)} k是介于0到n的
## 8.3
### 最优二叉树
递推公式的推导.   
![](https://github.com/wangree/lc-practice/blob/master/algorithm-design/08.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/Screenshot_20211230_115220_com.flyersoft.moonreaderp.jpg)
二叉树个数 卡特兰数的推导https://zhuanlan.zhihu.com/p/38607233
```cpp
//基本递推公式是C(i,j)=sum(pi,p_(i+1),...,pj)+min(c(i,k-1)+c(k+1,j)),k介于i，j之间，初始条件是c(j+1,j)=0,c(j,j)=p[j]
#include <iostream>
#include <vector>
#include "float.h"
#include<iomanip>
double C[100][100];
double p[100];
double sump[100];
int N;
int R[100][100];
using namespace std;
void input() {
    cin >> N;
    for (int i=0; i< N;i++) {
        cin >> p[i];
    }

}
void init(double arrayTwo[][100]) {
    for (int i=0; i< N;i++) {
        sump[i+1] = sump[i]+p[i];
    }
    for (int i = 0; i < N; i++)
    {
        arrayTwo[i][i] = p[i];
        arrayTwo[i+1][i] = 0;
    }
    for (int i = 0; i < N; i++)
    {
        R[i][i] = i;
    }    
}

void CalC(double arrayTwo[][100]) {
    for (int diag = 1; diag < N; diag++) {
        for (int i = 0; i < N-diag; i++)
        {
            int j = i+diag;
            arrayTwo[i][j] = DBL_MAX;
            for (int k = i; k <=j ; k++)
            {
              
                double p =  (k-1 <0)? 0 :arrayTwo[i][k-1];
                double q = arrayTwo[k+1][j];
                double temp = p+q+sump[j+1]-sump[i];
                if ((temp < arrayTwo[i][j])) {
                    arrayTwo[i][j] =  temp;
                    R[i][j] = k;  
                }
            }
            
        }   
    }    
}


void showresult() {
    cout<<setiosflags(ios::fixed)<<setprecision(6)<<setiosflags(ios::left);
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            cout << C[i][j] << " ";
        }
        cout << endl;
    }
    cout << "=========================" << endl;
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            cout << R[i][j] << " ";
        }
        cout << endl;
    }
} 
int main() {
    input();
    init(C);
    CalC(C);
    showresult();
}
```
注意填充的顺序 对角线填充可以联系线性方程 为什么要用对角线的方式 首先起始条件在对角线上 其次对于元素(I,j), 要得到它需要的元素在其右下 理解这个 也要联系二维内的一些特征 类似线性规划
### 习题8.3
最优查找二叉树并不是一定会把概率最高的点作为Root. 还是要看全局最优
#### 最优查找二叉树的优化
可以观察到Rij介于R i-1 j和R I j+1之间 所以可以把k的循环从i到j变为这个,其效率变为On2
## warshall算法和弗洛伊德算法
两者在每两个矩阵的迭代时 要注意K是不变的 i和j变化 再来理解计算的顺序；floyd算法是warshall算法的距离版
### warshall算法的效率，优化以及适用范围
warshall算法是立方级别的效率；warshall算法的优化方向：
三层循环如果第二层有0，不更新；第二层非0才进行更新；可以仅仅使用一个矩阵来进行更新，省空间；进一步可以将内两层循环变为位串的位或运算：
```cpp
if A[i,k]
    row[i]=row[i] bitwise row[k] //解释下如果仅仅是要得到，新的row[i]，则由于A[i,k]为1，则为row[k],但是由于还要考虑原值师是否是1，则需要bitwize or
```
对于邻接链表所描述的稀疏图，用普通的bfs/dfs遍历，假设有n个点，每个点与m个边相连，效率为O(nm)，如果是稠密的，m为n2量级，如果是稀疏的，则m很小，这个效率便远低于O(n3)；
使用warshall算法确定一个有向图是否是无环有向图不是一个好方法,因为4.2节有更好的方法；对于无向图，最终通过warshall得到的矩阵中，i不等于j时，T[i,j]为1，当且仅当i，j位于同一个联通分量中，则显然用遍历 的方法更容易求出一个传递闭包来，而当i，j相等时当且仅当i并孤立点时才能得到T[i,i]=1,这个效率显然不如直接进行图遍历
### floyd算法的效率，优化以及适用范围
floyd算法也可以通过本地改写矩阵来得到下一个矩阵，以节省空间；另外一个优化是，通过在每次更新时记录更新的k点在矩阵P中，可以写递归进行反推，从而得到最短路径上所有的点：
```cpp
void FindPath(int i,int j, vector<int> Path)
{
    if P[i,j] {
      int k = P[i,j];
      FindPath[i,k];
      Path.push_back(k);
      FindPath[k,j];
    }
}
```
另外对于有负数距离的图，由于floyd是取小的，无法得到最短距离,而且甚至会随着循环的进行一直趋于负无穷，反而可以利用这一点检测是否有负数距离；
### 撒棒问题
找出相连的游戏棒
首先，要扫描出两两相连的信息，这个可以使用暴力算法或者其他图算法，也可以使用nlogn的算法，然后再使用bfs dfs找到联通分量，不宜使用floyd效率较低


