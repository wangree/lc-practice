## 计数排序法
比较排序法，数字分布较广，需要一遍一遍扫出比当前数字小的个数,在扫描时能够知道比i小的元素数量，同时也能够对更新与i比较的元素j更小的数量,效率为O(n^2);
数字全部来自一个已知小集合时，采用一个map计数排序有时候在有重复数字的排序中非常好用，类似于书中的分布计数排序；分布计数的经典算法是首先知道输入数据的范围然后扫描一遍数据，得到范围内每个数字出现个数计入数组d，然后再对d各个数字进行累加得到某个数字应该在的最后一个位置，然后从右向左，将数字放到记录的位置并把其d中记录位置减1
## 数字交换
不使用额外空间的交换
U=u+v
V= U -v
U= u -v
或者
U=u^v
V= U^v
U= u^v
## 如何判断一个节点u是不是另一个节点v的祖先
对于有序有根树先前序遍历，再后续遍历，如果前序中u的index小于v的，且后序中u的index大于v的，则u是v的祖先
## 前缀和
空间换时间 先求出一个前缀和数组 再多次询问投个区间的和时能够很快得到结果 hdu6345
## 差分
很多情况下 如Leetcode1094 我们不需要在很多个区间滑窗中去累加总和 只需要得到一个变化量的数组 进而很容易得到某个区间的总和
## BM字符串匹配法则和霍斯普尔提出的简化版本
首先是horspool算法，它首先会构造一个数组t,对于所有字母c，如果是c在模式中,t[c]代表c距离模式最右端的距离;如果不在模式中则代表整个模式的长度；在进行匹配时，从右向左进行匹配，如果发现模式不匹配，仅仅看模式对应的文本中最后一个元素d，将模式向右移动t[d]距离，再进行匹配，直到发现匹配字符或者遍历到了尽头。
而bm算法充分利用了在从右向左过程中模式尾部告诉我们的字符串文本信息，虽然也是在不匹配时模式向右移动，但是移动的距离比horspool更加激进，为max{d_1,d_2},d_1是关于模式和不匹配字符的距离， d_2是关于自身重复性的相关距离,d_2的移动距离要大于等于hospool法的距离,这证明了haspool的正确性和bm的高效率。
具体来说，d_1是max{t[c]-k,1},这里的k是指在模式匹配过程中从右向左能够匹配的字母个数，而c是从右向左第一个不匹配的字母，t还是和horspool同样的表，t[c]-k代表模式中的c距离文本中的c的距离，而当c不在模式中时，该值会使得模式刚好跳过c,到达匹配部分；而如果这个值是负数，说明文本中的c在模式中的c的左侧，则没有必要去将两者对齐，直接将模式向右移动1即可。d_2是当从右向左匹配的字符串xxx和模式中xxx的距离，也就是要将模式中稍微偏左的xxx和文本中的xxx对齐；如果不存在xxx，xxx长度为k时，d_2为模式中l<k的后缀ppp和同样的前缀ppp之间的距离。
因为对齐模式中的重复部分和对齐不匹配字符在真正匹配的文本中肯定是同时满足的，所以我们取两者的max作为最终的模式移动距离
## KMP算法
kmp这里的模式指针j回退和bm中模式向右移动是对等的，相对运动
kmp算法是从左到右扫描模式的，主要查看当模式扫描到j时，当文本中字符为c且不匹配时，j-1个字母和c组成的字符串的后缀与模式的前缀重叠部分长度为模式的下一个状态(DFA[c][j])，即这时侯应该移动到前缀和文本中c和j-1中的部分后缀对齐
### KMP状态机的构造
并不需要去扫描模式中前缀和后缀+c的重叠长度；PAT为模式首先对于DFA[PAT[j]][j],其值一定是j+1;而对于P=DFA[PAT[j]][X]其意义为对于模式中的P位置字母，它左侧的一定长度的字符串组成的字符串和模式中j+1左侧的同样长度(假设是l)字符串相同，j+1和P可以认为是等效状态，所以无论j+1或者P上不匹配的字符是什么，DFA[c][P]==DFA[c][j+1],所以可以用比较小的P对应的状态机值去给较大的j的状态机赋值  
注意不能跨越几个状态  
j=7 X=C的状态机结果应该是j=5  
ABCABCABX  
===ABCABCAB（模式）  
j=1，X=C的状态机结果是j=3  
ABX..  
ABCABCAB  
尽管j=7和j=0是有同样的后缀AB  
其实j=7的等效状态应该是j=4，所以不能跨越，最终代码如下
```cpp
//DFA初始均为0
DFA[PAT[0]][0]=1;
for(int X=0,j=1;j<M;j++) {
     for (every c) {
        DFA[c][j] = DFA[c][X];
     }
     DFA[PAT[j]][j] =j+1;
     X = DFA[PAT[j]][X];
}
```
## 散列字符串查找法

## 散列法
需要做题深化认识
## 以B树作索引
