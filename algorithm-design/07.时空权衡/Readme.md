## 计数排序法
比较排序法，数字分布较广，需要一遍一遍扫出比当前数字小的个数,在扫描时能够知道比i小的元素数量，同时也能够对更新与i比较的元素j更小的数量,效率为O(n^2);
数字全部来自一个已知小集合时，采用一个map计数排序有时候在有重复数字的排序中非常好用，类似于书中的分布计数排序；分布计数的经典算法是首先知道输入数据的范围然后扫描一遍数据，得到范围内每个数字出现个数计入数组d，然后再对d各个数字进行累加得到某个数字应该在的最后一个位置，然后从右向左，将数字放到记录的位置并把其d中记录位置减1
## 数字交换
不使用额外空间的交换
U=u+v
V= U -v
U= u -v
或者
U=u^v
V= U^v
U= u^v
## 如何判断一个节点u是不是另一个节点v的祖先
对于有序有根树先前序遍历，再后续遍历，如果前序中u的index小于v的，且后序中u的index大于v的，则u是v的祖先
## 前缀和
空间换时间 先求出一个前缀和数组 再多次询问投个区间的和时能够很快得到结果 hdu6345
## 差分
很多情况下 如Leetcode1094 我们不需要在很多个区间滑窗中去累加总和 只需要得到一个变化量的数组 进而很容易得到某个区间的总和
## BM字符串匹配法则和霍斯普尔提出的简化版本
首先是horspool算法，它首先会构造一个数组t,对于所有字母c，如果是c在模式中,t[c]代表c距离模式最右端的距离;如果不在模式中则代表整个模式的长度；在进行匹配时，从右向左进行匹配，如果发现模式不匹配，仅仅看模式对应的文本中最后一个元素d，将模式向右移动t[d]距离，再进行匹配，直到发现匹配字符或者遍历到了尽头。
而bm算法充分利用了在从右向左过程中模式尾部告诉我们的字符串文本信息，虽然也是在不匹配时模式向右移动，但是移动的距离比horspool更加激进，为max{d_1,d_2},d_1是关于模式和不匹配字符的距离， d_2是关于自身重复性的相关距离,d_2的移动距离要大于等于hospool法的距离,这证明了haspool的正确性和bm的高效率。
具体来说，d_1是max{t[c]-k,1},这里的k是指在模式匹配过程中从右向左能够匹配的字母个数，而c是从右向左第一个不匹配的字母，t还是和horspool同样的表，t[c]-k代表模式中的c距离文本中的c的距离，而当c不在模式中时，该值会使得模式刚好跳过c,到达匹配部分；而如果这个值是负数，说明文本中的c在模式中的c的左侧，则没有必要去将两者对齐，直接将模式向右移动1即可。d_2是当从右向左匹配的字符串xxx和模式中xxx的距离，也就是要将模式中稍微偏左的xxx和文本中的xxx对齐，但是要注意×××的前一个元素和最右侧xxx的前一个元素不同，不然也不算；如果不存在xxx，xxx长度为k时，d_2为模式中l<k的后缀ppp和同样的前缀ppp之间的距离,如果l也不存在则这个值是m。
因为对齐模式中的重复部分和对齐不匹配字符在真正匹配的文本中肯定是同时满足的，所以我们取两者的max作为最终的模式移动距离;但是注意只有d_2的表不能工作，因为在第一个字符也不匹配时就无法处理
Horspool也可以从左向右扫描，因为它仅仅根据最后一个字符来判断模式移动距离，而BM就不行
### horspool的最差例子
文本全0 模式为10000... 这个效率还不如蛮力法 蛮力法从左到右 所以这里是线性的
## KMP算法
kmp这里的模式指针j回退和bm中模式向右移动是对等的，相对运动
kmp算法是从左到右扫描模式的，主要查看当模式扫描到j时，当文本中字符为c且不匹配时，j-1个字母和c组成的字符串的后缀与模式的前缀重叠部分长度为模式的下一个状态(DFA[c][j])，即这时侯应该移动到前缀和文本中c和j-1中的部分后缀对齐
### KMP状态机的构造
并不需要去扫描模式中前缀和后缀+c的重叠长度；PAT为模式首先对于DFA[PAT[j]][j],其值一定是j+1;而对于P=DFA[PAT[j]][X]其意义为对于模式中的P位置字母，它左侧的一定长度的字符串组成的字符串和模式中j+1左侧的同样长度(假设是l)字符串相同，则j+1和P可以认为是等效状态(j+1和p可以不同)，所以无论j+1或者P上不匹配的字符是什么，DFA[c][P]==DFA[c][j+1],所以可以用比较小的P对应的状态机值去给较大的j的状态机赋值  
注意不能跨越几个状态  
j=7 X=C的状态机结果应该是j=5  
ABCABCABX  
===ABCABCAB（模式）  
j=1，X=C的状态机结果是j=3  
ABX..  
ABCABCAB  
尽管j=7和j=1是有同样的后缀AB  
其实j=7的等效状态应该是j=4，所以不能跨越，最终代码如下
```cpp
//DFA初始均为0
DFA[PAT[0]][0]=1;
for(int X=0,j=1;j<M;j++) {
     for (every c) {
        DFA[c][j] = DFA[c][X];
     }
     DFA[PAT[j]][j] =j+1;
     X = DFA[PAT[j]][X];
}
```
## 散列字符串查找法
$$ x_i = R^{M-1}*t_i + R^{M-2}*t_{i+1}+t_{i+m-1} $$
t从i到I+M-1是模式对应文本的字符串，如果模式右移一位则有
$$x_{i+1} = R(x_i-R^{M-1}*t_i)+t_{i+m}$$
$$ h(x_i)=x_i mod Q $$
$h(x_i)$为最终结果
## 确定一个数组T是否是另一个S循环右移的结果
可以把问题转换为SS中是否包含T,用BM去解决
## 散列法
### 散列函数
正整数常常采用除留余数法，散列数组总数为M，最好取素数；浮点数对二进制进行除留余数法；字符串采用horner算法;组合键使用类似的算法；使用软缓存，在第一次计算完成后后面直接返回某个值的hash值。总的来说，一个好的散列方法应该满足：一致性，高效性，均匀性
### 均匀散列假设
假设使用的散列函数能够均匀且独立地将所有键散布到0到M-1之间
### 拉链法散列表（分离链，闭散列）
首先有个一数组，然后数组中每个元素代表一个散列链表，链表中的值具有相同的hash值；  
定理：均匀分布假设下，任意一条链表中的键的数量大概率为N/M(一条链含有k个键的概率呈现出泊松分布）;未命中查找和插入操作所需比较次数为~N/M,平均需要检查的指针个数为$1+\alpha/2$和$\alpha$
### 线性探测散列表（开散列）
元素所在位置（index)大于等于其散列值,而且在和散列值之间没有nuLl,于是我们用一个含有空元素数组的循环数组（查找到最后一个非空元素不匹配时，要接着遍历0位元素）就可以表示一个散列表，不需要多个链表，这时候的N/M就小于1了（M为数组大小）
在一张大小为M并含有$ N= \alpha * M $个键的基于线性探测的散列表中，在均匀散列假设下，命中和未命中的探测次数分别为：
$ ~1/2 * (1+1/(1-\alpha))$和$ ~1/2 * (1+1/(1-\alpha)^2)$
#### 调整数组大小
删除时，N<M/8,大小应该减少一半；插入时N>8*M,大小应该增加一倍；而拉链法不是必须的
### 双散列
在散列发生碰撞时，散列值都为l,使用另一个散列函数s(k),(l+s(k))mod m,(l+2s(k))mod m...作为新的散列值
### 生日悖论
当一个房间里有22人以上时，其中两个人生日相同的概率大于1/2，就是说散列碰撞是非常常见的
### 拉链法维护有序链表
有序时查找时遇到比它大的即可停止，另外删除和插入都会受益；这种情况要给总体排序可以使用k路合并排序
### 散列也是变治法的一种：改变表现
## 以B树作索引
B树的阶数指它最多可拥有的子树数量，因为是最多，所以一般都不满
### B树必须要满足的特性
