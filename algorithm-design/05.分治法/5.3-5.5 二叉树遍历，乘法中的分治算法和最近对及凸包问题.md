# 5.3 二叉树遍历及其相关特性
扩展树：把空子树当作节点，叫外部节点，其他节点都算内部节点
完全二叉树：每个节点的子节点数目是0或者2
遍历方式：前序（中左右），中序（左中右），后序（左右中）
## 如何从某两种顺序的结果还原二叉树结构
方法其实很简单就是用后序遍历结果厘清根结点，用中序遍历结果理清左右子树，再分别对左右子树重复以上步骤，对于两者有矛盾的情况，代码中的体现是如果某个子问题的中序遍历集合和后序遍历集合不相等则返回-1
## 掰巧克力和二叉树的对应
n*m大小的巧克力，每次只能沿着直线掰，一分为二，所以这个动作可以理解分成了左右子树，因而最后的结果是要n*m个叶结点或者把他们看成外部节点，则内部节点是n*m-1个，则说明至少要掰n*m-1次
## 最近对问题分治算法
可以利用分治的思想求最近对，首先把这些点按x排序生成序列p,然后把这些点按y排序生成序列q,以x方向上的中垂线吧所有点分为两半，继续递归计算；得到结果取最小的距离d,然后将q中所有∣x-m|<d的点构成点集s，在s中的点y方向距离小于dmin的(dmin初始值为d,每遇到一对更近的点更新一下),每次更新蛮力遍历得到互相
距离更新dmin,最终得到最小的dmin，效率属于nlogn级别
## 凸包问题分治算法
首先用x为所有点排序找到最左侧点p1和右侧点pn,利用叉乘判断其他在p1pn的左侧右侧或者在其上，左侧点和p1pn构成上包，右侧点和p1pn构成下包，对于上包寻找到距离p1pn最大的点pmax，它肯定是凸包顶点，如果有多个则取p1pmaxpn角度最大的那个，这时候可以对p1 pmax及其左侧点做同样的操作递归计算得到最终凸包，最差效率是O(n^2),平均是nlogn
快包算法的最优Case是所有点在一条线上，因为这时候分治出的两个包都是空的
，最差效率是(n^2),每次分治只能实现规模减一，比如P1和Pn取圆周半径的两个端点，所有点都在圆周上，Pi是Pi-1和Pn的中点
## 证明最近对合并垂直带中的p距离其小于dmin的点不超过7个
从点P开始做中轴的垂线，以中轴和垂线的夹角为一个边长为dmin的正方形的一角，将该正方形划分为4个，将在中轴其左侧对称的正方形也划分为4个，总共8个全等的正方形，每个正方形边长为d/2,显然每个正方形不可能包括超过一个候选点，再去掉p自身所在的正方形，会发现候选点只有7个
## voronoi图
对于点集P,Pi的voronoi多边形指平面x上某区域，该区域内的所有点到该点的距离小于其他Pj的距离。所有pi的voronoi多边形构成voronoi图
对于三个点的voronoi图是三点的中垂线划分而成的
## 平面上1000个点，得到100个10边形
按x从左到右排序，编号为1到1000，前10个点，对于1和10构成的边，要么在其一侧那么按顺序连接这些点再加上这条边，要么在两侧，则这条线把这些点分成两半，分别按顺序连接，则可以得到一个10边形，对于后面1990点重复此方法即可

