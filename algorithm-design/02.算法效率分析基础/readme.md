# 2.1 分析框架
## 输入规模的度量
## 运行时间的度量单位：操作数 
## 增长次数
## 算法的最优，最差和平均效率
   平均效率是各种输入类型的效率的期望
## 习题
   手套和袜子配对是最能体现最优，最差效率的问题
# 2.2 渐进符号和基本效率类型
## 史特林公式
n!的估计
## 习题
算法分析常常会使用O,代表效率小于等于，这是最常用的
### 设计theta(1)的算法确定假币比真币重还是轻
分一半称重，然后对得到的两个一半再分一半称重，仍然相同的是真的，假的在出现不等的那堆，那堆重则假币重，反之亦然
### 墙上的门 无限延伸的墙有两个方向在某处有个门 距离为n但未知 设计算法到门的时间为O(n)
钟摆式走法 https://blog.csdn.net/u012439764/article/details/81986762
关键是看步长怎么增长到n 线性增长到n太慢导致总和太大
#2.3 非递归算法的数学分析
## 分析非递归算法的通用方案
1 决定那个参数作为输入规模。 
2 确定基本操作。
3 检查基本操作的执行次数是否只依赖于输入规模。如果还要依赖其他特性则需要把最差 最优平均分开讨论。
4 建立基本操作的求和表达式求出结果或者增长次数
# 2.3 非递归算法的数学分析
是上一节的实践
## 习题2.3
### 11. 高斯消元法
直接去看代码不是非常好懂，有对应矩形四个顶点的元素，a[i,i],a[j,i],a[i,k],a[j,k],消去的是a[j,i],这里赋值的是a[j,k],注意赋值的值并不是消去的值；此外，要注意对于非方阵，最多只能消去到对角线的末尾的前一个元素
### 冯·诺伊曼邻居问题
## 2.4 递归算法的数学分析
### 分析递归算法时间效率的通用方案
（1） 决定用哪个参数作为输入规模的度量
（2） 找出算法的基本操作
（3） 检查对于相同规模的不同输入效率是否有差异，若有则需要分开对最差，最优平均效率做区分
（4） 将递归算法中，次一级规模的操作给定为T(n`),建立T(n)和T(n`)之间的基本操作执行次数的递推关系式
（5） 解递推关系式
### 汉诺塔游戏
n个大小不一的盘子和3根柱子，利用3根柱子将将所有盘子都移动到第3根柱子上去，但是不要将大盘放到小盘上，每次只能动一个盘子
递归的将n-1盘子从1挪到2，再将最大盘挪到3，再将n-1盘子递归的从2挪到3  
汉诺塔游戏是个标准的递归问题,先要把N-1个盘挪到2上(1) 再把最大盘挪到3上 最后把n-1个盘挪到3上(2) 会发现1和3两个步骤是一个规模变小的汉诺塔问题，因而可以递归下去
#### 挪动次数
首先要明确哪一步挪动哪个盘子，发现挪动第n个盘子到第三根柱子上一共需要挪动该盘2^n-1次
#### 非递归版本1
第m步移动的盘子序号是m用二进制表示的最低位bit为1的位置，首先弄清楚了某步做挪动哪个盘子；其次每个盘子的挪动顺序要么逆序（cbac)，要么顺序(abca),而且n-1和n大的盘的挪动顺序是相反的，
对于只有n个盘的情况，第n个盘应该是逆序的，因此据此可以开发其非递归版本
#### 非递归版本2
递归改造为堆栈版本
#### 非递归版本3和4
这个版本比较乱，详见网址：https://blog.csdn.net/yhf_naive/article/details/53384148
### 受限汉诺塔
要注意在尽管递归在写的时候大致和两块盘子的情况是一致的，但是不能完全等同，hanoi(n-1,a,c,b)就不能拆成hanoi(n-1,a,b,c)和hanoi(n-1,b,c,a),n>2时实际程序运行也不是如此，要注意我们在递归中只能构思一个打包的概念，具体的只能是单个盘挪动的动作，其他都不要引申
#### 对递归和堆栈修改的思考
递归的一层进入另一层的访问，相当于入栈，一般是到了栈底才进行真正的处理即出栈，对于递归和对应堆栈版本的相似性，这里有以下结论：  
1. 任何的递归和堆栈都有对应的树形结构，要思考清楚树形结构
2. 出栈即处理
3. 入栈的顺序可以由出栈来引导，不需要到底部才出栈，比如二叉树的前序遍历，dfs访问等算法，处理顺序对于结果无影响或者刚好与递归的访问顺序（入栈顺序）相吻合；也可以是利用参数变化人为迭代，比如阶乘，汉诺塔，二叉树的中序遍历和后序遍历，一直到底部才进行处理出栈;而递归算法是一定要压到底部才出栈的，这才是比较普遍的出入栈顺序，某层访问完全处理完了其递归调用树的父结点才出栈肯定是没有问题的，而这个完全处理完了就需要具体代码中去把握。
4. 由3还可以得出，stack递归模拟的入栈顺序需要和递归一致，由父及子，出栈顺序可以有不同 
#### 所有汉诺塔解法见hanuota.cpp
#### 常见递归还有求是否完全图
#### 名人问题
问题大致是：名人的定义是所有人都认识他，但是他不认识其他人，求解一群人里面是否有名人  
适合使用递归：
n=1时有名人；
n>1时
第一步，随机挑出ab两人，如果a认识b，则a肯定不是名人，将a排除得到集合n-1；如果a不认识b,则b不是名人，排除b得到集合n-1;  
第二步，对集合n-1进行递归调用，递归的结果返回n-1中是否有名人和哪个是名人；
第三步，如果第二步中没有名人，则集合n也没有名人；如果有名人c，则查看c是否认识第一步中排除的人，如果认识，则没有名人，如果不认识，则查看排除的人是否认识名人，不认识则有名人，认识则没有名人；如果第二步有名人b,则查看b是否认识a，认识则无，不认识则有；如果第二步有名人a,查看b是否认识a，认识则有名人，不认识则无。
所以递归并非那么无脑的
### 2.5 计算第n个斐波那契数
如果使用递归方法，则会有很多的重复递归调用，对于f(n)=f(n-1)+f(n-2)这种递归关系式，即带常系数的二阶线性递推式，求解可以得到f(n)的非递推形式是n次幂增长的，实际上不使用递归，直接用数组 f[n]进行遍历迭代，仅仅是线性的效率；另外也可以对递归稍作改造：
```cpp
//非齐次递归变成了齐次递归，但其实必要性不大
int F[100];
int fibs(n)
{
   if n<=1 return n;
   F[n]= fibs(n-1)+F[n-2];
   return F[n];
}
```
此外，更高效的算法是矩阵乘法，是一个logn效率的算法
### 习题2.5
1. 斐波那契兔是普通斐波那契数列的后一项
2. 假设每一步可以爬一格或者两格梯子，爬n格梯子有多少种方法，递归的思想就很适合这道题，可以得到一个斐波那契数列的递推关系
3. 斐波那契数列的奇偶性具有周期性
4. 斐波那契数列的递归算法调用f(1)和f(0)的次数，依然可以从递推关系入手
5. fibs最简方式不需要数列，只需要两个临时变量
6. 分解斐波那契矩形也是利用递归的思想最后得到和斐波那契数列相似的结果
7. 计算第n个斐波那契数列的最后5位数，这个可以在每次得到新值后进行取10^5的运算，后面位数的运算和前面无关
### 2.6 算法的经验分析
#### 线性同余法
r[i]=(r[i-1]*a-b)mod m  
r[0]为seed
#### 欧几里得算法与斐波那契数列
要进行k次除法运算的最小整数对是fibs(k+2),fibs(k+1)
#### 欧几里得算法的效率
logn的效率，平均除法次数D是gcd(n,1),gcd(n,2),gcd(n,n)的除法平均次数，其具体值为12ln2/pai^2

