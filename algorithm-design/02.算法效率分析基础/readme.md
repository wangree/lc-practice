# 2.1 分析框架
## 输入规模的度量
## 运行时间的度量单位：操作数 
## 增长次数
## 算法的最优，最差和平均效率
   平均效率是各种输入类型的效率的期望
## 习题
   手套和袜子配对是最能体现最优，最差效率的问题
# 2.2 渐进符号和基本效率类型
## 史特林公式
n!的估计
## 习题
算法分析常常会使用O,代表效率小于等于，这是最常用的
### 设计theta(1)的算法确定假币比真币重还是轻
分一半称重，然后对得到的两个一半再分一半称重，仍然相同的是真的，假的在出现不等的那堆，那堆重则假币重，反之亦然
### 墙上的门 无限延伸的墙有两个方向在某处有个门 距离为n但未知 设计算法到门的时间为O(n)
钟摆式走法 https://blog.csdn.net/u012439764/article/details/81986762
关键是看步长怎么增长到n 线性增长到n太慢导致总和太大
#2.3 非递归算法的数学分析
## 分析非递归算法的通用方案
1 决定那个参数作为输入规模。 
2 确定基本操作。
3 检查基本操作的执行次数是否只依赖于输入规模。如果还要依赖其他特性则需要把最差 最优平均分开讨论。
4 建立基本操作的求和表达式求出结果或者增长次数
# 2.3 非递归算法的数学分析
是上一节的实践
## 习题2.3
### 11. 高斯消元法
直接去看代码不是非常好懂，有对应矩形四个顶点的元素，a[i,i],a[j,i],a[i,k],a[j,k],消去的是a[j,i],这里赋值的是a[j,k],注意赋值的值并不是消去的值；此外，要注意对于非方阵，最多只能消去到对角线的末尾的前一个元素
### 冯·诺伊曼邻居问题
## 2.4 递归算法的数学分析
### 分析递归算法时间效率的通用方案
（1） 决定用哪个参数作为输入规模的度量
（2） 找出算法的基本操作
（3） 检查对于相同规模的不同输入效率是否有差异，若有则需要分开对最差，最优平均效率做区分
（4） 建立基本操作执行次数的递推关系式
（5） 解递推关系式
### 汉诺塔游戏
n个大小不一的盘子和3根柱子，利用3根柱子将将所有盘子都移动到第3根柱子上去，但是不要将大盘放到小盘上，每次只能动一个盘子
递归的将n-1盘子从1挪到2，再将最大盘挪到3，再将n-1盘子递归的从2挪到3. 
汉诺塔游戏是个标准的递归问题,先要把N-1个盘挪到2上(1) 再把最大盘挪到3上 最后把n-1个盘挪到3上(2) 会发现1和3两个步骤是一个规模变小的汉诺塔问题，因而可以递归下去
