# 2.1 分析框架
## 输入规模的度量
## 运行时间的度量单位：操作数 
## 增长次数
## 算法的最优，最差和平均效率
   平均效率是各种输入类型的效率的期望
## 习题
   手套和袜子配对是最能体现最优，最差效率的问题
# 2.2 渐进符号和基本效率类型
## 史特林公式
n!的估计
## 习题
算法分析常常会使用O,代表效率小于等于，这是最常用的
### 设计theta(1)的算法确定假币比真币重还是轻
分一半称重，然后对得到的两个一半再分一半称重，仍然相同的是真的，假的在出现不等的那堆，那堆重则假币重，反之亦然
### 墙上的门 无限延伸的墙有两个方向在某处有个门 距离为n但未知 设计算法到门的时间为O(n)
钟摆式走法 https://blog.csdn.net/u012439764/article/details/81986762
关键是看步长怎么增长到n 线性增长到n太慢导致总和太大
#2.3 非递归算法的数学分析
## 分析非递归算法的通用方案
1 决定那个参数作为输入规模。 
2 确定基本操作。
3 检查基本操作的执行次数是否只依赖于输入规模。如果还要依赖其他特性则需要把最差 最优平均分开讨论。
4 建立基本操作的求和表达式求出结果或者增长次数
# 2.3 非递归算法的数学分析
是上一节的实践
## 习题2.3
### 11. 高斯消元法
直接去看代码不是非常好懂，有对应矩形四个顶点的元素，a[i,i],a[j,i],a[i,k],a[j,k],消去的是a[j,i],这里赋值的是a[j,k],注意赋值的值并不是消去的值；此外，要注意对于非方阵，最多只能消去到对角线的末尾的前一个元素
### 冯·诺伊曼邻居问题
## 2.4 递归算法的数学分析
### 分析递归算法时间效率的通用方案
（1） 决定用哪个参数作为输入规模的度量
（2） 找出算法的基本操作
（3） 检查对于相同规模的不同输入效率是否有差异，若有则需要分开对最差，最优平均效率做区分
（4） 将递归算法中，次一级规模的操作给定为T(n`),建立T(n)和T(n`)之间的基本操作执行次数的递推关系式
（5） 解递推关系式
### 汉诺塔游戏
n个大小不一的盘子和3根柱子，利用3根柱子将将所有盘子都移动到第3根柱子上去，但是不要将大盘放到小盘上，每次只能动一个盘子
递归的将n-1盘子从1挪到2，再将最大盘挪到3，再将n-1盘子递归的从2挪到3  
汉诺塔游戏是个标准的递归问题,先要把N-1个盘挪到2上(1) 再把最大盘挪到3上 最后把n-1个盘挪到3上(2) 会发现1和3两个步骤是一个规模变小的汉诺塔问题，因而可以递归下去
#### 挪动次数
首先要明确哪一步挪动哪个盘子，发现挪动第n个盘子到第三根柱子上一共需要挪动该盘2^n-1次
#### 非递归版本1
第m步移动的盘子序号是m用二进制表示的最低位bit为1的位置，首先弄清楚了某步做挪动哪个盘子；其次每个盘子的挪动顺序要么逆序（cbac)，要么顺序(abca),而且n-1和n大的盘的挪动顺序是相反的，
对于只有n个盘的情况，第n个盘应该是逆序的，因此据此可以开发其非递归版本
#### 非递归版本2
递归改造为堆栈版本
#### 非递归版本3和4
这个版本比较乱，详见网址：https://blog.csdn.net/yhf_naive/article/details/53384148
#### 对递归和堆栈修改的思考
递归的一层进入另一层的访问，相当于入栈，一般是到了栈底才进行真正的处理即出栈，对于递归和对应堆栈版本的相似性，这里有以下结论：  
1. 任何的递归和堆栈都有对应的树形结构，要思考清楚树形结构
2. 出栈即处理
3. 入栈的顺序可以由出栈来引导，不需要到底部才出栈，比如二叉树的前序遍历，dfs访问等算法，处理顺序对于结果无影响或者刚好与递归的访问顺序（入栈顺序）相吻合；也可以是利用参数变化人为迭代，比如阶乘，汉诺塔，二叉树的中序遍历和后序遍历，一直到底部才进行处理出栈;而递归算法是一定要压到底部才出栈的，这才是比较普遍的出入栈顺序，某层访问完全处理完了其递归调用树的父结点才出栈肯定是没有问题的，而这个完全处理完了就需要具体代码中去把握。
4. 由3还可以得出，stack递归模拟的入栈顺序需要和递归一致，由父及子，出栈顺序可以有不同 
#### 所有汉诺塔解法见hanuota.cpp

