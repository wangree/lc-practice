if continue的实现方式有问题：停下来一定是在low==high时，情况非常复杂；
```cpp
vector<int> input;
int partition(int l,int r){
    int divider=input[l];
    int low = l+1;
    int high = r;
    while(low<high){
        if (input[low]<divider){
            low++;
            continue;
        }
        if(input[high]>divider){
            high--;
            continue;
        }
        swap(input[low],input[high]);
    }
    swap(input[l],input[high-1]);
    return low;
}
void QuickSort(int l,int r){
    int divide;
    if(l<r){
        divide = partition(l,r);
        QuickSort(l,divide-1);
        QuickSort(divide+1,r);
    }
}
int main(){
    input={676378,66,33,56,5894,1,16,39};
    QuickSort(0,input.size()-1);
    return 0;
}
```
现在改为
```cpp
int partition(int l,int r){
    int divider=input[l];
    int low = l;
    int high = r+1;
    do{
        do {
            if(low==r) break;
            low++;

        }while(input[low]<divider);
        do {
            if(high==l) break;
            high--;

        }while(input[high]>divider);
        swap(input[low],input[high]);
    }while (low<high);
    swap(input[low],input[high]);
    swap(input[l],input[high]);
    return high;
}
```
